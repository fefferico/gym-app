import { Component, inject, OnInit, OnDestroy, signal, computed, ChangeDetectorRef, PLATFORM_ID, ViewChildren, QueryList, ElementRef, effect, ViewChild, afterNextRender, Injector, runInInjectionContext } from '@angular/core';
import { CommonModule, DatePipe, DecimalPipe, isPlatformBrowser } from '@angular/common';
import { ActivatedRoute, Router } from '@angular/router';
import { Subscription, timer, of, lastValueFrom, firstValueFrom, combineLatest, forkJoin, Observable } from 'rxjs';
import { switchMap, take, map, last } from 'rxjs/operators';
import {
  Routine,
  WorkoutExercise,
  ExerciseTargetSetParams,
  ActiveSetInfo,
  PlayerSubState,
  PausedWorkoutState,
  ExerciseTargetExecutionSetParams,
  ExerciseCurrentExecutionSetParams,
  METRIC,
  TimedSetState,
  RepsTargetType,
  RepsTarget,
  WeightTargetType,
  WeightTarget,
  DistanceTarget,
  DurationTarget,
  RestTarget,
  REPS_TARGET_SCHEMES,
  WEIGHT_TARGET_SCHEMES,
  AnyScheme,
  AnyTarget,
  DURATION_TARGET_SCHEMES,
  DISTANCE_TARGET_SCHEMES,
  REST_TARGET_SCHEMES,
} from '../../../core/models/workout.model';
import { Exercise } from '../../../core/models/exercise.model';
import { WorkoutService } from '../../../core/services/workout.service';
import { ExerciseService } from '../../../core/services/exercise.service';
import { TrackingService } from '../../../core/services/tracking.service';
import {
  LoggedSet,
  LoggedWorkoutExercise,
  WorkoutLog,
  PersonalBestSet,
  LastPerformanceSummary,
} from '../../../core/models/workout-log.model';
import { WeightUnitPipe } from '../../../shared/pipes/weight-unit-pipe';
import { AlertService } from '../../../core/services/alert.service';
import { UnitsService } from '../../../core/services/units.service';
import { ToastService } from '../../../core/services/toast.service';
import { v4 as uuidv4 } from 'uuid';
import { format } from 'date-fns';
import { IconComponent } from '../../../shared/components/icon/icon.component';
import { ExerciseSelectionModalComponent } from '../../../shared/components/exercise-selection-modal/exercise-selection-modal.component';
import { FormsModule } from '@angular/forms';
import { ActionMenuComponent } from '../../../shared/components/action-menu/action-menu';
import { ActionMenuItem } from '../../../core/models/action-menu.model';
import { TrainingProgramService } from '../../../core/services/training-program.service';
import { StorageService } from '../../../core/services/storage.service';
import { MenuMode, RestTimerMode, SummaryDisplayMode } from '../../../core/models/app-settings.model';
import { AppSettingsService } from '../../../core/services/app-settings.service';
import { TrainingProgram } from '../../../core/models/training-program.model';
import { AlertButton, AlertInput } from '../../../core/models/alert.model';
import { CdkDragDrop, DragDropModule, moveItemInArray } from '@angular/cdk/drag-drop';
import { addExerciseBtn, addRoundToExerciseBtn, addSetToExerciseBtn, addToSuperSetBtn, addWarmupSetBtn, calculatorBtn, createSuperSetBtn, exerciseInfoBtn, exerciseNotesBtn, finishEarlyBtn, metricsBtn, openSessionPerformanceInsightsBtn, pauseSessionBtn, quitWorkoutBtn, removeExerciseBtn, removeFromSuperSetBtn, removeRoundFromExerciseBtn, removeSetFromExerciseBtn, restBtn, resumeSessionBtn, sectionExerciseBtn, sessionNotesBtn, setNotesBtn, switchExerciseBtn, timerBtn } from '../../../core/services/buttons-data';
import { mapExerciseTargetSetParamsToExerciseExecutedSetParams } from '../../../core/models/workout-mapper';
import { ProgressiveOverloadService } from '../../../core/services/progressive-overload.service.ts';
import { BarbellCalculatorModalComponent } from '../../../shared/components/barbell-calculator-modal/barbell-calculator-modal.component';
import { NgLetDirective } from '../../../shared/directives/ng-let.directive';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { SessionOverviewModalComponent } from '../session-overview-modal/session-overview-modal.component';
import { FullScreenRestTimerComponent, TIMER_MODES } from '../../../shared/components/full-screen-rest-timer/full-screen-rest-timer';
import { AUDIO_TYPES, AudioService } from '../../../core/services/audio.service';
import { PressDirective } from '../../../shared/directives/press.directive';
import { SET_TYPE } from '../workout-builder';
import { BumpClickDirective } from '../../../shared/directives/bump-click.directive';
import { repsTargetAsString, repsTypeToReps, genRepsTypeFromRepsNumber, getDurationValue, durationToExact, getWeightValue, weightToExact, getDistanceValue, distanceToExact, restToExact, getRestValue, getRepsValue, repsToExact, weightTargetAsString, distanceTargetAsString, durationTargetAsString, restTargetAsString } from '../../../core/services/workout-helper.service';
import { WorkoutUtilsService } from '../../../core/services/workout-utils.service';
import { WorkoutSection } from '../../../core/models/workout-section.model';
import { WORKOUT_SECTION_TYPE_ORDER, WorkoutSectionType } from '../../../core/models/workout-section-type.model';
import { WorkoutSectionService } from '../../../core/services/workout-section.service';
import { ModalService } from '../../../core/services/modal.service';
import { EXERCISE_CATEGORY_TYPES } from '../../../core/models/exercise-category.model';
import { ThemeService } from '../../../core/services/theme.service';
import { NumbersOnlyDirective } from '../../../shared/directives/onlyNumbers.directive';
import { ModalComponent } from '../../../shared/components/modal/modal.component';
import { ExerciseDetailComponent } from '../../exercise-library/exercise-detail';
import { ShatterableDirective } from '../../../animations/shatterable.directive';
import e from 'express';

// Interface for saving the paused state

enum SessionState {
  Loading = 'loading',
  Playing = 'playing',
  Paused = 'paused',
  Error = 'error',
  End = 'end',
}

enum TimerSetState {
  Idle = 'idle',
  Running = 'running',
  Paused = 'paused',
  Completed = 'completed'
}

export interface NextStepInfo {
  completedExId: number,
  completedSetId: number,
  exerciseSetLength: number,
  maxExerciseIndex: number,
}

@Component({
  selector: 'app-compact-workout-player',
  standalone: true,
  imports: [
    CommonModule, DatePipe, IconComponent,
    ExerciseSelectionModalComponent, FormsModule, ActionMenuComponent, FullScreenRestTimerComponent, NgLetDirective,
    DragDropModule, BarbellCalculatorModalComponent, TranslateModule, SessionOverviewModalComponent, PressDirective,
    BumpClickDirective, NumbersOnlyDirective, ModalComponent, ExerciseDetailComponent, ShatterableDirective
  ],
  templateUrl: './compact-workout-player.component.html',
  styleUrls: ['./compact-workout-player.component.scss'],
  providers: [DecimalPipe, WeightUnitPipe, AudioService],
})
export class CompactWorkoutPlayerComponent implements OnInit, OnDestroy {
  private route = inject(ActivatedRoute);
  protected router = inject(Router);
  protected workoutService = inject(WorkoutService);
  protected workoutUtilsService = inject(WorkoutUtilsService);
  private exerciseService = inject(ExerciseService);
  protected trackingService = inject(TrackingService);
  protected trainingProgramService = inject(TrainingProgramService);
  protected storageService = inject(StorageService);
  protected alertService = inject(AlertService);
  protected modalService = inject(ModalService);
  protected toastService = inject(ToastService);
  protected unitsService = inject(UnitsService);
  private weightUnitPipe = inject(WeightUnitPipe);
  private cdr = inject(ChangeDetectorRef);
  protected appSettingsService = inject(AppSettingsService);
  protected progressiveOverloadService = inject(ProgressiveOverloadService);
  private platformId = inject(PLATFORM_ID);
  private injector = inject(Injector);
  private translate = inject(TranslateService);
  private themeService = inject(ThemeService);

  private workoutSectionService = inject(WorkoutSectionService);


  @ViewChildren(ShatterableDirective) shatterables!: QueryList<ShatterableDirective>;

  availablePlayerRepSchemes: { type: RepsTargetType; label: string }[] = [];


  private toggledSetAnimation = signal<{ key: string, type: 'set' | 'round', state: 'completed' | 'incompleted' } | null>(null);
  protected metricEnum = METRIC;

  isAddToSupersetModalOpen = signal(false);
  exerciseToSupersetIndex = signal<number | null>(null);
  expandedSets = signal(new Set<string>());
  setTimerState = signal<{ [key: string]: { status: TimerSetState, remainingTime: number } }>({});
  private setTimerSub: Subscription | undefined;

  lastExerciseId = signal<string>('');
  lastExerciseSetId = signal<string>('');

  private lastLoggedSetForRestUpdate: LoggedSet | null = null;

  protected getMenuMode(): MenuMode {
    return this.appSettingsService.getMenuMode();
  }

  protected getShowMetricTarget(): boolean {
    return this.appSettingsService.isShowMetricTarget();
  }

  protected restTimerModeEnum = RestTimerMode;
  protected getRestTimerMode() {
    return this.appSettingsService.getRestTimerMode();
  }

  protected summaryDisplayModeEnum = SummaryDisplayMode;
  protected getSummaryDisplayMode() {
    return this.appSettingsService.getSummaryDisplayMode();
  }

  lastSetInfo = computed<ActiveSetInfo | null>(() => {
    const routine = this.routine();
    const exerciseId = this.lastExerciseId();
    const setId = this.lastExerciseSetId();

    if (!exerciseId || !setId || !routine) return null;

    const exerciseData = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exerciseData) return null;

    const setData = this.getSetById(routine, exerciseId, setId);
    if (!setData) return null;

    const completedSetLog = this.getLoggedSet(exerciseId, setId);

    let baseExerciseInfo: Exercise | undefined;
    this.exerciseService.getExerciseById(exerciseData.exerciseId).subscribe(ex => {
      baseExerciseInfo = ex;
    });

    return {
        exerciseIndex: exIndex,
        setIndex: sIndex,
      exerciseId: exerciseId,
      setId: setId,
        supersetId: exerciseData.supersetId || null,
        superSetType: exerciseData.supersetType || null,
      exerciseData: exerciseData,
      setData: setData,
      type: (setData.type as 'standard' | 'warmup' | 'amrap' | 'custom') ?? 'standard',
      baseExerciseInfo: baseExerciseInfo,
      isCompleted: !!completedSetLog,
      actualReps: completedSetLog?.repsLogged,
      actualWeight: completedSetLog?.weightLogged,
      actualDuration: completedSetLog?.durationLogged,
      actualDistance: completedSetLog?.distanceLogged,
      actualRest: completedSetLog?.restLogged,
      notes: completedSetLog?.notes || setData?.notes,

    };
  });

  displayExercises = computed(() => {
    const routine = this.routine();
    if (!routine || !routine.exercises) return [];
    return routine.exercises;
  });

  routine = signal<Routine | null | undefined>(undefined);
  program = signal<TrainingProgram | null | undefined>(undefined);
  scheduledDay = signal<string | undefined>(undefined);
  originalRoutineSnapshot = signal<Routine | null | undefined>(undefined);
  sessionState = signal<SessionState>(SessionState.Loading);
  protected sessionStateEnum = SessionState;
  protected timerSetEnum = TimerSetState;
  sessionTimerDisplay = signal('00:00');
  expandedExerciseId = signal<string | null>(null);
  activeExerciseMenuId = signal<string | null>(null);
  mainSessionActionMenuOpened = signal<boolean>(false);
  playerSubState = signal<PlayerSubState>(PlayerSubState.PerformingSet);

  showCompletedSetsForExerciseInfo = signal(true);
  showCompletedSetsForDayInfo = signal(false);

  isRestTimerVisible = signal(false);
  restDuration = signal(0);
  restTimerMainText = signal(this.translate.instant('compactPlayer.rest'));
  restTimerNextUpText = signal<string | null>(this.translate.instant('compactPlayer.loading'));
  restTimerNextSetDetails = signal<ExerciseTargetSetParams | null>(null);


  private compactRestStartTimestamp: number | null = null;
  private compactRestDuration: number = 0;
  /**
 * Returns the remaining rest time in seconds.
 */
  restTimerRemaining(): number {
    if (!this.isRestTimerVisible()) return 0;
    if (this.getRestTimerMode() !== this.restTimerModeEnum.Compact) {
      // fallback for fullscreen or other modes
      return this.restDuration();
    }
    if (this.compactRestStartTimestamp === null) return this.compactRestDuration;
    const elapsed = Math.floor((Date.now() - this.compactRestStartTimestamp) / 1000);
    const remaining = this.compactRestDuration - elapsed;
    return Math.max(0, remaining);
  }

  /**
   * Returns the progress of the rest timer as a percentage (0-100).
   */
  restTimerProgress(): number {
    const total = this.compactRestDuration;
    const remaining = this.restTimerRemaining();
    if (!total || total <= 0) return 0;
    const elapsed = total - remaining;
    return Math.max(0, Math.min(100, (elapsed / total) * 100));
  }
  menuModeDropdown: boolean = false;
  menuModeCompact: boolean = false;
  menuModeModal: boolean = false;

  private intensityAdjustment: { direction: 'increase' | 'decrease', percentage: number } | null = null;

  private workoutStartTime: number = 0;
  private sessionTimerElapsedSecondsBeforePause = 0;
  private timerSub: Subscription | undefined;
  private routeSub: Subscription | undefined;
  private isSessionConcluded = false;

  private readonly PAUSED_WORKOUT_KEY = 'fitTrackPro_pausedWorkoutState';
  private readonly PAUSED_STATE_VERSION = '1.0';

  routineId: string | null = null;
  programId: string | null = null;

  currentWorkoutLog = signal<Partial<WorkoutLog>>({ exercises: [], notes: '' });
  currentWorkoutLogExercises = computed(() => this.currentWorkoutLog()?.exercises ?? []);

  defaultExercises: Exercise[] = [];
  availableExercises: Exercise[] = [];

  isAddExerciseModalOpen = signal(false);
  isSwitchExerciseModalOpen = signal(false);
  isPerformanceInsightsModalOpen = signal(false);
  isShowingSimilarInSwitchModal = signal(false);
  exercisesForSwitchModal = signal<Exercise[]>([]);

  modalSearchTerm = signal('');
  exerciseToSwitchId = signal<string | null>(null);
  insightsData = signal<{
    exercise: WorkoutExercise;
    baseExercise: Exercise | null;
    lastPerformance: LastPerformanceSummary | null;
    personalBests: PersonalBestSet[];
    completedSetsInSession: LoggedSet[];
  } | null>(null);
  // For missing exercise replacement workflow
  missingExerciseReplacementModal = signal(false);
  missingExerciseToReplace = signal<WorkoutExercise | null>(null);
  missingExerciseReplacementCallback = signal<((exercise: Exercise | null) => void) | null>(null);

  emomState = signal<{ [key: string]: { status: TimerSetState, remainingTime: number } }>({});
  private emomTimerSub: Subscription | undefined;

  workoutProgress = computed(() => {
    const routine = this.routine();
    const log = this.currentWorkoutLog();
    if (!routine || !routine.exercises || routine.exercises.length === 0) {
      return 0;
    }
    // The total planned sets is simply the sum of all sets from all exercises.
    const totalPlannedSets = routine.exercises.reduce((sum, ex) => sum + (ex.sets?.length ?? 0), 0);
    if (totalPlannedSets === 0) {
      return 0;
    }
    const totalCompletedSets = log.exercises?.reduce((total, ex) => total + ex.sets.length, 0) || 0;
    return Math.min(100, (totalCompletedSets / totalPlannedSets) * 100);
  });

  sectionProgress(section: WorkoutSection, log: Partial<WorkoutLog>) {
    const totalSets = section.exercises.reduce((sum, ex) => sum + (ex.sets?.length ?? 0), 0);
    const completedSets = section.exercises.reduce((sum, ex) => {
      const logEx = log.exercises?.find(le => le.exerciseId === ex.exerciseId);
      return sum + (logEx?.sets.length ?? 0);
    }, 0);
    return totalSets ? Math.min(100, (completedSets / totalSets) * 100) : 0;
  }

  getSectionProgressColor(section: WorkoutSection | null): string {
    switch (section?.type) {
      case WorkoutSectionType.WARM_UP: return '#f59e0b'; // amber-500
      case WorkoutSectionType.MAIN_LIFT: return '#ef4444'; // red-500
      case WorkoutSectionType.CARDIO: return '#3b82f6'; // blue-500
      case WorkoutSectionType.FINISHER: return '#a855f7'; // purple-500
      case WorkoutSectionType.COOL_DOWN: return '#10b981'; // emerald-500
      // default: return '#6b7280'; // gray-500
      default: return 'white gray-500'; // gray-500
    }
  }


  @ViewChildren('exerciseCard') exerciseCards!: QueryList<ElementRef>;
  @ViewChild('header') header!: ElementRef; // Get the header element

  private audioService = inject(AudioService);
  private lastBeepSecond: number | null = null;


  @ViewChildren('setCard') setCards!: QueryList<ElementRef<HTMLDivElement>>;
  @ViewChildren('roundCard') roundCards!: QueryList<ElementRef<HTMLDivElement>>;

  constructor() {
    // --- START: ADDED SNIPPET (Part 2) ---
    // Effect that runs when the animation signal changes
    effect(() => {
      const animationState = this.toggledSetAnimation();
      if (!animationState) return;

      const { key, type, state } = animationState;

      // Use a timeout to ensure the DOM query runs after the current change detection cycle
      setTimeout(() => {
        const animationClass = state === 'completed' ? 'animate-bump-in' : 'animate-bump-out';

        let cardElement: HTMLElement | undefined;

        if (type === 'set') {
          // Find the specific #setCard element
          cardElement = this.setCards.find(card => card.nativeElement.getAttribute('data-set-id') === key.split('-')[1])?.nativeElement;
        } else { // type === 'round'
          // Find the specific #roundCard element
          const roundIndex = key.split('-')[1];
          cardElement = this.roundCards.find(card => card.nativeElement.getAttribute('data-round-id') === roundIndex)?.nativeElement;
        }

        if (cardElement) {
          cardElement.classList.add(animationClass);
          // Remove the class after the animation completes so it can be re-triggered
          setTimeout(() => {
            cardElement?.classList.remove(animationClass);
          }, 300); // Duration should match the animation duration in CSS
        }
      }, 0);
    });

    effect(() => {
      const notesKey = this.expandedSetNotes();
      const metricsKey = this.expandedMetricsSection();

      if (!notesKey && !metricsKey) return;

      setTimeout(() => {
        // Handle notes section animation
        if (notesKey) {
          const notesElement = document.querySelector(`[data-notes-section="${notesKey}"]`) as HTMLElement;
          if (notesElement) {
            notesElement.classList.add('animate-bump-in');
            setTimeout(() => notesElement?.classList.remove('animate-bump-in'), 300);
          }
        }

        // Handle metrics section animation
        if (metricsKey) {
          const metricsElement = document.querySelector(`[data-metrics-section="${metricsKey}"]`) as HTMLElement;
          if (metricsElement) {
            metricsElement.classList.add('animate-bump-in');
            setTimeout(() => metricsElement?.classList.remove('animate-bump-in'), 300);
          }
        }
      }, 0);
    });
    // --- END: ADDED SNIPPET (Part 2) ---
  }



  async ngOnInit(): Promise<void> {
    if (isPlatformBrowser(this.platformId)) { window.scrollTo(0, 0); }
    this.loadAvailableExercises();
    this.availablePlayerRepSchemes = this.workoutUtilsService.getAvailableRepsSchemes('player');


    this.menuModeDropdown = this.appSettingsService.isMenuModeDropdown();
    this.menuModeCompact = this.appSettingsService.isMenuModeCompact();
    this.menuModeModal = this.appSettingsService.isMenuModeModal();

    const hasPausedSession = await this.checkForPausedSession();
    if (!hasPausedSession) {
      this.loadNewWorkoutFromRoute();
    }
  }

  private isDestroyed = false;
  ngOnDestroy(): void {
    this.isDestroyed = true;
    // Save paused session if there is a routine with at least one exercise,
    // and the session is not ended (even if no sets have been logged)
    const routine = this.routine();
    if (
      !this.isSessionConcluded &&
      routine &&
      routine.exercises &&
      routine.exercises.length > 0 &&
      this.sessionState() !== SessionState.End
    ) {
      this.savePausedSessionState();
    }
    this.timerSub?.unsubscribe();
    this.routeSub?.unsubscribe();
    this.emomTimerSub?.unsubscribe();
    this.setTimerSub?.unsubscribe();
    this.unlockScreenOrientation();
  }

  onExerciseDrop(event: CdkDragDrop<WorkoutExercise[]>) {
    const routine = this.routine();
    if (!routine?.exercises) return;

    const exercises = [...routine.exercises];

    // Map visible indices to actual indices
    // Visible exercises: standalone + group starts (first exercise of each group)
    const visibleIndices = exercises
      .map((ex, idx) => idx)
      .filter(idx => {
        const block = this.getBlockForExercise(exercises[idx].id);
        return block?.type === 'single' || this.getPositionInBlock(exercises[idx].id) === 0;
      });

    const draggedIndex = visibleIndices[event.previousIndex] ?? event.previousIndex;
    const targetIndex = visibleIndices[event.currentIndex] ?? event.currentIndex;

    if (draggedIndex < 0 || targetIndex < 0 || draggedIndex === targetIndex) return;

    const draggedItem = exercises[draggedIndex];
    const targetItem = exercises[targetIndex];

    const draggedIsInGroup = this.isExerciseInGroupBlock(draggedItem.id);
    const targetIsInGroup = this.isExerciseInGroupBlock(targetItem.id);
    const draggedIsSupersetStart = draggedIsInGroup && this.getPositionInBlock(draggedItem.id) === 0;
    const draggedIsStandalone = !draggedIsInGroup;
    const targetIsStandalone = !targetIsInGroup;

    // Case 1: Dragging a group block to a new position
    if (draggedIsSupersetStart) {
      const draggedBlockExercises = this.getExerciseIdsInSameBlock(draggedItem.id);
      const draggedBlockSize = draggedBlockExercises.length;

      // Find all indices in the dragged block
      const draggedBlockIndices = exercises
        .map((ex, idx) => idx)
        .filter(idx => draggedBlockExercises.includes(exercises[idx].id))
        .sort((a, b) => a - b);

      // Move the entire block
      const blockItems = draggedBlockIndices.map(idx => exercises[idx]);
      draggedBlockIndices.forEach(idx => exercises.splice(idx, 1));

      // Re-insert at target
      exercises.splice(targetIndex, 0, ...blockItems);
    }
    // Case 2: Standard drag for standalone exercises
    else if (draggedIsStandalone && targetIsStandalone) {
      const [draggedExercise] = exercises.splice(draggedIndex, 1);
      exercises.splice(targetIndex, 0, draggedExercise);
    }
    // Other cases: no-op or handle edge cases as needed

    routine.exercises = exercises;
    this.workoutService.synchronizeRoutineBlocks(routine);
    this.routine.set({ ...routine });
  }

  /**
  * Ensures a specific metric exists in a set's fieldOrder and has a default value if not set.
  * @param set The set to modify.
  * @param metric The metric to ensure (e.g., METRIC.reps).
  * @param defaultValue The default value to assign if the target is null or undefined.
  */
  private _ensureMetricInSet(set: ExerciseTargetSetParams, metric: METRIC, defaultValue: number): void {
    if (!set.fieldOrder) {
      set.fieldOrder = [];
    }

    if (!set.fieldOrder.includes(metric)) {
      set.fieldOrder.push(metric);

      switch (metric) {
        case METRIC.reps:
          if (!set.targetReps) {
            set.targetReps = { type: RepsTargetType.exact, value: defaultValue }
          };
          break;
        case METRIC.weight:
          if (set.targetWeight == null) set.targetWeight = weightToExact(defaultValue);
          break;
        case METRIC.duration:
          if (set.targetDuration == null) set.targetDuration = durationToExact(defaultValue);
          break;
      }
    }
  }

  private async loadNewWorkoutFromRoute(): Promise<void> {
    this.sessionState.set(SessionState.Loading);
    this.isSessionConcluded = false;

    this.routeSub = combineLatest([
      this.route.paramMap,
      this.route.queryParamMap
    ]).pipe(
      map(([params, queryParams]) => ({
        routineId: params.get('routineId'),
        programId: queryParams.get('programId'),
        scheduledDayId: queryParams.get('scheduledDayId'),
      })),
      switchMap(ids => {
        this.routineId = ids.routineId;
        this.programId = ids.programId;
        if (ids.scheduledDayId) {
          this.scheduledDay.set(ids.scheduledDayId);
        }
        return this.routineId ? this.workoutService.getRoutineById(this.routineId) : of(null);
      }),
      switchMap(routine => {
        if (!routine) return of(null); // Pass nulls through
        return this.translateRoutineExercises$(routine); // Return the translation observable
      })
    ).subscribe(async (routine) => {
      if (this.isDestroyed) { return; }
      if (routine) {
        // Validate that all exercises in the routine exist
        routine = await this.validateAndFixMissingExercises(routine);
        this.syncRoutineBlocksAfterModification(routine);

        // If all exercises were removed, treat as new routine
        if (routine.exercises.length === 0) {
          this.toastService.warning(
            this.translate.instant('compactPlayer.alerts.allExercisesRemovedOrMissing'),
            5000
          );
          this.showCreationWizard();
          return;
        }

        // We capture the routine before adjustments so we can apply them to a copy
        let routineForSession = JSON.parse(JSON.stringify(routine)) as Routine;

        // When in True Gym Mode, ensure all non-cardio exercises have weight and reps fields.
        // if (this.appSettingsService.isTrueGymMode()) {
        const exercisesMap = new Map(this.availableExercises.map(ex => [ex.id, ex]));

        routineForSession.exercises.forEach(exercise => {
          const baseExercise = exercisesMap.get(exercise.exerciseId);
          if (baseExercise) {
            exercise.sets.forEach(set => {
              if (baseExercise?.categories?.find(cat => cat === EXERCISE_CATEGORY_TYPES.cardio) === undefined) {
                // For non-cardio, ensure weight and reps fields are present
                this._ensureMetricInSet(set, METRIC.reps, 8); // Default 8 reps
                this._ensureMetricInSet(set, METRIC.weight, 10); // Default 10 weight
              } else {
                // For cardio, ensure the duration field is present
                this._ensureMetricInSet(set, METRIC.duration, 300); // Default 300s (5 min)
              }
            });
          }
        });
        // }

        const lastLogArray = await firstValueFrom(this.trackingService.getLogsForRoutine(routine.id, 1));
        const lastLog = lastLogArray.length > 0 ? lastLogArray[0] : null;

        if (lastLog && lastLog.perceivedWorkoutInfo?.perceivedEffort) {
          const effort = lastLog.perceivedWorkoutInfo.perceivedEffort;
          let adjustmentType: 'increase' | 'decrease' | null = null;
          let dialogTitle = '', dialogMessage = '';

          if (effort >= 7) {
            adjustmentType = 'decrease';
            dialogTitle = this.translate.instant('compactPlayer.alerts.toughWorkoutTitle');
            dialogMessage = this.translate.instant('compactPlayer.alerts.toughWorkoutMessage');
          } else if (effort <= 4) {
            adjustmentType = 'increase';
            dialogTitle = this.translate.instant('compactPlayer.alerts.lightWorkoutTitle');
            dialogMessage = this.translate.instant('compactPlayer.alerts.lightWorkoutMessage');
          }

          if (adjustmentType) {
            const prompt = await this.alertService.showPromptDialog(
              dialogTitle, dialogMessage,
              [{
                name: 'percentage', type: 'number', placeholder: 'e.g., 10', value: 10,
                attributes: { min: '1', max: '50', step: '1' }
              }] as AlertInput[],
              this.translate.instant('compactPlayer.alerts.adjustBy'), this.translate.instant('compactPlayer.alerts.noThanks')
            );

            if (prompt && prompt['percentage']) {
              const percentage = Number(prompt['percentage']);
              // Store the adjustment preference instead of applying it immediately
              this.intensityAdjustment = { direction: adjustmentType, percentage };
              this.toastService.success(this.translate.instant('compactPlayer.toasts.intensityAdjusted', { percent: percentage }), 3000, this.translate.instant('compactPlayer.toasts.intensityAdjustedTitle'));
            }
          }
        }

        this.routine.set(routineForSession); // Use the (potentially unmodified) routine copy
        this.originalRoutineSnapshot.set(JSON.parse(JSON.stringify(routine))); // Snapshot is always the true original
        if (this.sessionState() !== SessionState.End) {
          await this.prefillRoutineWithLastPerformance();
        }
        if (this.programId) {
          this.program.set(await firstValueFrom(this.trainingProgramService.getProgramById(this.programId)));
        }
        this.startWorkout();
      } else {
        // COMPLETELY NEW ROUTINE
        this.showCreationWizard();
      }
    });
  }


  private async prefillRoutineWithLastPerformance(): Promise<void> {
    const currentRoutine = this.routine();
    if (!currentRoutine) return;

    const poSettings = this.progressiveOverloadService.getSettings();
    const isPoEnabled = poSettings.enabled && poSettings.strategies && poSettings.sessionsToIncrement && poSettings.sessionsToIncrement > 0;

    // Fetch all logs for this routine only if PO is enabled
    const allLogsForRoutine = isPoEnabled
      ? await firstValueFrom(this.trackingService.getLogsForRoutine(currentRoutine.id))
      : [];

    // Deep copy to avoid mutating the original
    const routineCopy = JSON.parse(JSON.stringify(currentRoutine)) as Routine;

    // Track which exercises had overload applied
    const overloadAppliedForExercise: boolean[] = [];
    const overloadedExercisesDetails: string[] = [];

    // Track if we need to prompt for historical/original (only if at least one exercise has historical data and no overload)
    let hasAnyHistorical = false;
    let lastPerformances: (LastPerformanceSummary | null)[] = [];

    // Gather last performances for all exercises
    for (const exercise of routineCopy.exercises) {
      try {
        const lastPerformance = await firstValueFrom(
          this.trackingService.getLastPerformanceForExercise(exercise.exerciseId)
        );
        lastPerformances.push(lastPerformance);
        if (lastPerformance && lastPerformance.sets && lastPerformance.sets.length > 0) {
          hasAnyHistorical = true;
        }
      } catch (error) {
        lastPerformances.push(null as any);
      }
    }

    // --- 1. Progressive Overload Pass ---
    const overloadedExercises: string[] = [];

    for (const [exIndex, exercise] of routineCopy.exercises.entries()) {
      let overloadApplied = false;
      const lastPerformance = lastPerformances[exIndex];

      if (isPoEnabled && lastPerformance && lastPerformance.sets && lastPerformance.sets.length > 0) {
        // Filter logs that actually contain the current exercise
        const relevantLogs = allLogsForRoutine.filter(log =>
          log.exercises.some(le => le.exerciseId === exercise.exerciseId)
        );

        if (relevantLogs.length >= poSettings.sessionsToIncrement!) {
          const recentLogsToCheck = relevantLogs.slice(-poSettings.sessionsToIncrement!);
          let allSessionsSuccessful = true;

          for (const log of recentLogsToCheck) {
            const loggedEx = log.exercises.find(le => le.exerciseId === exercise.exerciseId);
            const originalEx = this.getWorkoutExerciseById(this.originalRoutineSnapshot()!, exercise.exerciseId);

            if (!loggedEx || !originalEx || loggedEx.sets.length < originalEx.sets.length) {
              allSessionsSuccessful = false;
              break;
            }

            const wasSuccess = originalEx.sets.every((originalSet, setIndex) => {
              if (originalSet.type === 'warmup') return true;
              const loggedSet = loggedEx.sets[setIndex];
              if (!loggedSet) return false;

              // List of metrics to check
              const metrics: Array<{ target: any, logged: any, compare: (a: any, b: any) => boolean }> = [
                {
                  target: originalSet.targetReps,
                  logged: loggedSet.repsLogged,
                  compare: (logged, target) => repsTypeToReps(logged) >= repsTypeToReps(target)
                },
                {
                  target: originalSet.targetWeight,
                  logged: loggedSet.weightLogged,
                  compare: (logged, target) => getWeightValue(logged) >= getWeightValue(target)
                },
                {
                  target: originalSet.targetDuration,
                  logged: loggedSet.durationLogged,
                  compare: (logged, target) => getDurationValue(logged) >= getDurationValue(target)
                },
                {
                  target: originalSet.targetDistance,
                  logged: loggedSet.distanceLogged,
                  compare: (logged, target) => getDistanceValue(logged) >= getDistanceValue(target)
                }
                // Add more metrics if needed
              ];

              // For each metric, if there's a target, there must be a logged value that meets/exceeds it
              for (const { target, logged, compare } of metrics) {
                if (target !== undefined && target !== null) {
                  if (logged === undefined || logged === null) return false;
                  if (!compare(logged, target)) return false;
                }
                // If there's a logged value but no target, consider it succeeded (do nothing)
              }

              return true;
            });

            if (!wasSuccess) {
              allSessionsSuccessful = false;
              break;
            }
          }

          // ...inside the for loop after overload is applied...
          if (allSessionsSuccessful) {
            // Save old main values before overload
            const mainSet = exercise.sets.find(s => s.type !== 'warmup');
            const oldWeight = mainSet?.targetWeight ? getWeightValue(mainSet.targetWeight) : undefined;
            const oldReps = mainSet?.targetReps ? repsTypeToReps(mainSet.targetReps) : undefined;
            const oldDuration = mainSet?.targetDuration ? getDurationValue(mainSet.targetDuration) : undefined;
            const oldDistance = mainSet?.targetDistance ? getDistanceValue(mainSet.targetDistance) : undefined;

            this.progressiveOverloadService.applyOverloadToExercise(exercise, poSettings);

            // Get new main values after overload
            const newMainSet = exercise.sets.find(s => s.type !== 'warmup');
            const newWeight = newMainSet?.targetWeight ? getWeightValue(newMainSet.targetWeight) : undefined;
            const newReps = newMainSet?.targetReps ? repsTypeToReps(newMainSet.targetReps) : undefined;
            const newDuration = newMainSet?.targetDuration ? getDurationValue(newMainSet.targetDuration) : undefined;
            const newDistance = newMainSet?.targetDistance ? getDistanceValue(newMainSet.targetDistance) : undefined;

            // Build a bullet list for each metric
            const metricLines: string[] = [];
            if (oldWeight !== undefined && newWeight !== undefined && newWeight > oldWeight) {
              const diff = newWeight - oldWeight;
              metricLines.push(`${this.translate.instant('metrics.weight')}: ${newWeight} ${this.unitsService.getWeightUnitSuffix()} (${diff > 0 ? '+' : ''}${diff} ${this.unitsService.getWeightUnitSuffix()})`);
            }
            if (oldReps !== undefined && newReps !== undefined && newReps > oldReps) {
              const diff = newReps - oldReps;
              metricLines.push(`${this.translate.instant('metrics.reps')}: ${newReps} (${diff > 0 ? '+' : ''}${diff} rep${Math.abs(diff) === 1 ? '' : 's'})`);
            }
            if (oldDuration !== undefined && newDuration !== undefined && newDuration > oldDuration) {
              const diff = newDuration - oldDuration;
              metricLines.push(`${this.translate.instant('metrics.duration')}: ${newDuration} sec (${diff > 0 ? '+' : ''}${diff} sec)`);
            }
            if (oldDistance !== undefined && newDistance !== undefined && newDistance > oldDistance) {
              const diff = newDistance - oldDistance;
              metricLines.push(`${this.translate.instant('metrics.distance')}: ${newDistance} m (${diff > 0 ? '+' : ''}${diff} m)`);
            }
            if (metricLines.length > 0) {
              overloadedExercisesDetails.push(`<strong class="text-gray-900 dark:text-white">${exercise.exerciseName ?? exercise.id}</strong>`);
              metricLines.forEach(line =>
                overloadedExercisesDetails.push(`<span class="ml-6 block text-gray-600 dark:text-gray-400">${line}</span>`)
              );
            }
            overloadApplied = true;
          }
        }
      }
      overloadAppliedForExercise[exIndex] = overloadApplied;
    }

    // --- 2. Prompt for historical/original if needed (only if at least one exercise has historical and no overload) ---
    let useHistorical = false;
    if (hasAnyHistorical && overloadAppliedForExercise.some(applied => !applied)) {
      // Only prompt if Progressive Overload is NOT enabled
      if (!isPoEnabled) {
        const userChoice = await this.alertService.showConfirmationDialog(
          this.translate.instant('compactPlayer.alerts.prefillTitle'),
          this.translate.instant('compactPlayer.alerts.prefillMessage'),
          [
            { text: this.translate.instant('compactPlayer.alerts.useHistorical'), role: 'confirm', data: 'historical', icon: 'clock' },
            { text: this.translate.instant('compactPlayer.alerts.useOriginal'), role: 'cancel', data: 'original', icon: 'schedule' }
          ]
        );
        useHistorical = userChoice?.data === 'historical';
      }
      // If isPoEnabled is true, we don't prompt and useHistorical remains false (PO overrides historical)
    }

    // Show feedback to the user after all overloads are applied - ONLY if PO is enabled
    if (isPoEnabled && overloadedExercisesDetails.length > 0) {
      await this.modalService.prompt({
        title: this.translate.instant('compactPlayer.toasts.progressiveOverloadAppliedMultipleTitle'),
        message: '<p class="font-semibold text-green-600 dark:text-green-400 mb-2">Progressive overload has been applied!</p>' +
          this.translate.instant('compactPlayer.toasts.progressiveOverloadAppliedMultipleMessage'),
        listItems: overloadedExercisesDetails,
        listClass: 'list-none pl-0 space-y-2',
        confirmText: this.translate.instant('common.ok'),
        renderAsHtml: true
      });
    }

    // --- 3. Apply historical values if chosen and not overloaded ---
    for (const [exIndex, exercise] of routineCopy.exercises.entries()) {
      if (!overloadAppliedForExercise[exIndex] && useHistorical) {
        const lastPerformance = lastPerformances[exIndex];
        if (lastPerformance && lastPerformance.sets && lastPerformance.sets.length > 0) {
          exercise.sets.forEach((set, setIndex) => {
            const historicalSet = lastPerformance.sets[setIndex];
            if (historicalSet) {
              set.targetReps = historicalSet.repsLogged ?? set.targetReps;
              set.targetWeight = historicalSet.weightLogged ?? set.targetWeight;
              set.targetDuration = historicalSet.durationLogged ?? set.targetDuration;
              set.targetDistance = historicalSet.distanceLogged ?? set.targetDistance;
            }
          });
        }
      }
      // else: stick to original routine (do nothing)
    }

    // --- 4. Apply session-wide intensity adjustment (if any) ---
    if (this.intensityAdjustment) {
      const { direction, percentage } = this.intensityAdjustment;
      const multiplier = direction === 'increase' ? 1 + (percentage / 100) : 1 - (percentage / 100);

      routineCopy.exercises.forEach(exercise => {
        exercise.sets.forEach(set => {
          if (set.targetWeight != null) {
            const adjustedWeight = Math.round((getWeightValue(set.targetWeight) * multiplier) * 4) / 4;
            set.targetWeight = weightToExact(adjustedWeight >= 0 ? adjustedWeight : 0);
          }
          if (set.targetReps != null) {
            const adjustedReps = Math.round(repsTypeToReps(set.targetReps) * multiplier);
            set.targetReps = adjustedReps >= 0 ? genRepsTypeFromRepsNumber(adjustedReps) : genRepsTypeFromRepsNumber(0);
          }
          if (set.targetDuration != null) {
            const adjustedDuration = Math.round(getDurationValue(set.targetDuration) * multiplier);
            set.targetDuration = durationToExact(adjustedDuration >= 0 ? adjustedDuration : 0);
          }
          if (set.targetDistance != null) {
            const adjustedDistance = Math.round(getDistanceValue(set.targetDistance) * multiplier);
            set.targetDistance = distanceToExact(adjustedDistance >= 0 ? adjustedDistance : 0);
          }
        });
      });
    }

    // --- 5. Update the routine and trigger change detection ---
    this.routine.set(routineCopy);
    this.cdr.detectChanges();
  }

  startWorkout(): void {
    if (isPlatformBrowser(this.platformId)) {
      window.scrollTo({ top: 0, behavior: 'instant' });
    }

    this.workoutStartTime = Date.now();
    this.sessionState.set(SessionState.Playing);
    this.currentWorkoutLog.set({
      routineId: this.routineId ?? undefined,
      programId: this.programId ?? undefined,
      scheduledDayId: this.scheduledDay() ?? undefined,
      routineName: this.routine()?.name,
      startTime: this.workoutStartTime,
      date: format(new Date(), 'yyyy-MM-dd'),
      exercises: [],
      notes: '',
    });

    this._prefillPerformanceInputs();
    this.startSessionTimer();

    if (this.routine()) {
      //this.toggleExerciseExpansion(0);
      this.scrollToSet('', '');
    }
    this.alignRestStartTimestampsFromLog();
  }

  startSessionTimer(): void {
    if (this.timerSub) this.timerSub.unsubscribe();
    this.timerSub = timer(0, 1000).subscribe(() => {
      if (this.sessionState() === SessionState.Playing) {
        const currentDeltaSeconds = Math.floor((Date.now() - this.workoutStartTime) / 1000);
        const totalElapsedSeconds = this.sessionTimerElapsedSecondsBeforePause + currentDeltaSeconds;
        const mins = String(Math.floor(totalElapsedSeconds / 60)).padStart(2, '0');
        const secs = String(totalElapsedSeconds % 60).padStart(2, '0');
        this.sessionTimerDisplay.set(`${mins}:${secs}`);
      }
    });
  }

  isCardio(exercise: WorkoutExercise): boolean {
    const base = this.availableExercises.find(e => e.id === exercise.exerciseId);
    return base?.categories.find(cat => cat === EXERCISE_CATEGORY_TYPES.cardio) !== undefined;
  }

  isCardioByIndex(exerciseId: string): boolean {
    const routine = this.routine();
    if (!routine) return false;

    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return false;

    // Use the pre-loaded 'availableExercises' array for a fast, synchronous lookup
    const baseExercise = this.availableExercises.find(ex => ex.id === exercise.exerciseId);
    return !!(baseExercise?.categories.find(cat => cat === EXERCISE_CATEGORY_TYPES.cardio));
  }

  isDistancedExercise(exerciseId: string): boolean {
    const base = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!base) {
      return false;
    }
    return !!base?.sets?.some(set => set.targetDistance) || this.isCardio(base);
  }

  isDurationExercise(exerciseId: string): boolean {
    const base = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!base) {
      return false;
    }
    return !!base?.sets?.some(set => set.targetDuration);
  }

  isSetDataValid(exerciseId: string, setId: string): boolean {
    // 1. Check for any invalid inputs first. If invalid, can't complete.
    if (this.hasInvalidInput(exerciseId, setId)) {
      return false;
    }

    // 2. Ensure at least one metric has a meaningful value.
    const routine = this.routine();
    if (!routine) return false;

    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return false;

    const plannedSet = exercise.sets.find(set => set.id === setId);
    if (!plannedSet) return false;

    const key = this.getSetKey(exercise.id, plannedSet.id);
    const userInputs = this.performanceInputValues()[key] || {};

    // Get the effective values to validate (user input > planned)
    const weight = userInputs.actualWeight ?? plannedSet.targetWeight;
    const reps = userInputs.actualReps ?? plannedSet.targetReps;
    const distance = userInputs.actualDistance ?? plannedSet.targetDistance;
    const duration = userInputs.actualDuration ?? plannedSet.targetDuration;

    // Check if any value is present and meaningful. Weight is meaningful even at 0 (bodyweight).
    const hasWeight = weight !== undefined && weight !== null;
    const hasReps = reps !== undefined && reps !== null && repsTypeToReps(reps) !== 0;
    const hasDistance = distance !== undefined && distance !== null && getDistanceValue(distance) > 0;
    const hasDuration = duration !== undefined && duration !== null && getDurationValue(duration) > 0;

    return hasWeight || hasReps || hasDistance || hasDuration;
  }

  getLoggedSet(exerciseId: string, setId: string): LoggedSet | undefined {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return undefined;

    const exerciseLog = this.currentWorkoutLog()?.exercises?.find(e => e.id === exercise.id);
    if (!exerciseLog) return undefined;

    if (!exercise.sets) return undefined;
    if (!this.getSetById(this.routine(), exerciseId, setId)) return undefined;
    const set = this.getSetById(this.routine(), exerciseId, setId);
    if (!set) return undefined;
    // Use a consistent, unique ID format for logged superset sets.
    const targetLoggedSetId = this.getPlannedSetId(exercise, set);

    return exerciseLog.sets.find(s => s.plannedSetId === targetLoggedSetId);
  }

  getExerciseTotalLoggedSets(exerciseId: string): number {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return 0;

    const exerciseLogs = this.currentWorkoutLog()?.exercises?.find(e => e.exerciseId === exercise.exerciseId);
    if (!exerciseLogs) return 0;

    return exerciseLogs?.sets?.length;
  }

  getExerciseTotalSets(exerciseId: string): number {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return 0;

    return exercise.sets?.length || 0;
  }

  isSetCompleted(exerciseId: string, setId: string): boolean {
    // If roundId is not provided (from older calls), default to '0'.
    return !!this.getLoggedSet(exerciseId, setId);
  }

  isExerciseLogged(exerciseId: string): boolean {
    return !!this.currentWorkoutLog()?.exercises?.find(e => e.id === exerciseId);
  }

  updateExerciseNotes(exerciseId: string, event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.routine.update(r => {
      if (!r) return r;

      // Create a new exercises array with the updated note
      const newExercises = r.exercises.map((ex) => {
        if (ex.id === exerciseId) {
          // Return a new object for the exercise being changed
          return { ...ex, notes: value };
        }
        return ex; // Return the original object for all other exercises
      });

      // Also update the log in real-time if the exercise is already logged
      const log = this.currentWorkoutLog();
      const loggedEx = log.exercises?.find(ex => ex.id === exerciseId);
      if (loggedEx) {
        loggedEx.notes = value;
        this.currentWorkoutLog.set({ ...log });
      }

      // Return a new routine object containing the new exercises array
      return { ...r, exercises: newExercises };
    });
  }

  async editSessionNotes() {
    this.openNoteModal('session');
  }

  getInitialExerciseNoteInputValue(exerciseId: string): string {
    const exercise = this.getWorkoutExerciseById(this.routine()!, exerciseId);
    if (exercise) {
      return exercise.notes || '';
    }
    return '';
  }

  parseTimeToSeconds(timeStr: string): number {
    if (!timeStr) return 0;
    const parts = timeStr.split(':').map(part => parseInt(part, 10) || 0);
    return parts.length === 2 ? parts[0] * 60 + parts[1] : parts[0];
  }

  /**
     * Formats a single numeric value of seconds into a "mm:ss" string.
     * @param seconds The number of seconds to format.
     * @returns The formatted time string, or an empty string if the input is invalid.
     */
  private _formatSingleSecondValue(seconds: number | string): string {
    const numericValue = Number(seconds);
    // Return empty if the value is not a valid number
    if (isNaN(numericValue)) {
      return '';
    }

    const mins = String(Math.floor(numericValue / 60)).padStart(2, '0');
    const secs = String(numericValue % 60).padStart(2, '0');
    return `${mins}:${secs}`;
  }

  /**
   * Formats a total number of seconds into a "mm:ss" time string.
   * It can also handle a string representing a range (e.g., "60-90"),
   * which it will format as "01:00-01:30".
   *
   * @param totalSeconds The total seconds as a number, a string, or a range string.
   * @returns The formatted time string.
   */
  formatSecondsToTime(totalSeconds: number | string | undefined): string {
    // 1. Handle null, undefined, or empty string inputs
    if (totalSeconds == null || totalSeconds === '') {
      return '';
    }

    // 2. Check if the input is a range string (e.g., "60-90")
    if (typeof totalSeconds === 'string' && totalSeconds.includes('-')) {
      const [minSeconds, maxSeconds] = totalSeconds.split('-');

      // Format both parts of the range individually using the helper
      const formattedMin = this._formatSingleSecondValue(minSeconds);
      const formattedMax = this._formatSingleSecondValue(maxSeconds);

      // Return the combined formatted range
      return `${formattedMin}-${formattedMax}`;
    }

    // 3. If it's not a range, format it as a single value using the helper
    return this._formatSingleSecondValue(totalSeconds);
  }

  toggleExerciseExpansion(exerciseId: string): void {
    const isOpening = this.expandedExerciseId() !== exerciseId;
    this.expandedExerciseId.update(current => (isOpening ? exerciseId : null));

    if (isOpening) {
      const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
      if (exercise) {
        // If it's a superset, handle round expansion
        if (this.isSupersetStart(exerciseId)) {
          // const firstIncompleteRoundIndex = exercise.sets.findIndex((set, roundIdx) => !this.isRoundCompleted(exIndex, roundIdx));
          // const newExpandedRounds = new Set<string>();
          // if (firstIncompleteRoundIndex > -1) {
          //   newExpandedRounds.add(`${exIndex}-${firstIncompleteRoundIndex}`);
          // }
          // this.expandedRounds.set(newExpandedRounds);
        }
        // If it's a standard exercise, handle set expansion
        else if (!this.isSuperSet(exerciseId)) {
          const firstIncompleteSetIndex = exercise.sets.findIndex((set, setIdx) => !this.isSetCompleted(exercise.id, set.id));
          const newExpandedSets = new Set<string>();
          if (firstIncompleteSetIndex > -1) {
            newExpandedSets.add(this.getSetKey(exerciseId, exercise.sets[firstIncompleteSetIndex].id));
          }
          // EXPAND FIRST SET
          // this.expandedSets.set(newExpandedSets);
        }
      }

      // The afterNextRender logic for scrolling remains the same
      runInInjectionContext(this.injector, () => {
        if (this.isDestroyed) {
          return;
        }
        afterNextRender(() => {

          requestAnimationFrame(() => {
            const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
            const headerElement = this.header?.nativeElement;
            const cardElement = document.querySelector(`[data-exercise-id="${exerciseId}"]`) as HTMLElement;

            if (!cardElement || !headerElement || !exercise) {
              return; // Failsafe
            }

            let targetElement: HTMLElement | null = null;

            // Check if any sets for THIS specific exercise have been logged.
            const hasLoggedSetsForThisExercise = this.getExerciseTotalLoggedSets(exerciseId) > 0;

            // --- SCROLL LOGIC ---
            if (hasLoggedSetsForThisExercise) {
              if (this.isSupersetStart(exerciseId)) {
                const targetRoundIndex = exercise.sets.findIndex((set, roundIdx) => !this.isRoundCompleted(exerciseId, set.id));
                if (targetRoundIndex > -1) {
                  targetElement = cardElement.querySelector(`[data-round-id="${targetRoundIndex}"]`);
                }
              } else if (!this.isSuperSet(exerciseId)) {
                const targetSetIndex = exercise.sets.findIndex((set, setIdx) => !this.isSetCompleted(exercise.id, set.id));
                if (targetSetIndex > -1) {
                  targetElement = cardElement.querySelector(`[data-set-id="${targetSetIndex}"]`);
                }
              }
            }
            // If NO sets have been logged for this exercise, 'targetElement' will remain null,
            // which correctly triggers a scroll to the card header below.

            // --- EXECUTE SCROLL ---
            const headerHeight = headerElement.offsetHeight;
            let scrollTopPosition: number;

            if (targetElement) {
              // Scroll to the first uncompleted set/round
              const elementTopPosition = targetElement.getBoundingClientRect().top + window.scrollY;
              scrollTopPosition = elementTopPosition - headerHeight - 10;
            } else {
              // Scroll to the card header itself
              const cardTopPosition = cardElement.getBoundingClientRect().top + window.scrollY;
              scrollTopPosition = cardTopPosition - headerHeight - 10;
            }

            // window.scrollTo({ top: scrollTopPosition, behavior: 'smooth' });
            this.scrollCurrentElementIntoView(exercise.id, exercise.sets[0].id);
          });
        });
      });
    } else {
      // When closing a card, clear the round states
      this.expandedRounds.set(new Set<string>());
      this.expandedSets.set(new Set<string>()); // Also clear sets
    }
  }

  expandedExerciseNotes = signal<number | null>(null);
  expandedSetNotes = signal<string | null>(null); // Key will be "exerciseId-setId"
  expandedRounds = signal(new Set<string>());

  toggleExerciseNotes(exerciseId: string, event?: Event) {
    event?.stopPropagation();
    // this.expandedExerciseNotes.update(current => current === exIndex ? null : exIndex);
    this.openNoteModal('exercise', exerciseId);
  }

  toggleSetNotes(exerciseId: string, setId: string, event: Event) {
    this.openNoteModal('set', exerciseId, setId);
  }

  // compact-workout-player.component.ts

  async finishWorkout(): Promise<void> {
    const log = this.currentWorkoutLog();
    const loggedExercisesForReport = (log.exercises || []).filter(ex => ex.sets.length > 0);

    if (loggedExercisesForReport.length === 0) {
      this.toastService.info(this.translate.instant('compactPlayer.toasts.noSetsLoggedError'), 3000);
      return;
    }

    // 1. Analyze completion to decide the prompt's tone (Finish vs. Finish Early)
    const analysis = this.analyzeWorkoutCompletion();
    const hasIncomplete = analysis.incompleteExercises.length > 0 || analysis.skippedExercises.length > 0;
    const title = hasIncomplete ? this.translate.instant('compactPlayer.alerts.finishEarlyTitle') : this.translate.instant('compactPlayer.alerts.finishTitle');

    // =================== START OF MODIFICATION ===================
    let message = this.translate.instant('compactPlayer.alerts.finishMessage'); // Default for a fully completed workout

    if (hasIncomplete) {
      const skippedCount = analysis.skippedExercises.length;
      const incompleteCount = analysis.incompleteExercises.length;
      const messageParts: string[] = [];

      // Add parts to the message only if their count is greater than zero.
      if (skippedCount > 0) {
        messageParts.push(this.translate.instant('compactPlayer.alerts.skippedDetailSimple', { count: skippedCount }));
      }
      if (incompleteCount > 0) {
        messageParts.push(this.translate.instant('compactPlayer.alerts.incompleteDetailSimple', { count: incompleteCount }));
      }

      // Join the parts with a simple 'and'. You can also make ' and ' a translation key if needed.
      const details = messageParts.join(' and ');

      // Use a base message that incorporates the dynamic details.
      message = this.translate.instant('compactPlayer.alerts.finishEarlyMessageSimple', { details: details });
    }
    // =================== END OF MODIFICATION ===================


    const confirmFinish = await this.alertService.showConfirm(title, message, this.translate.instant('compactPlayer.alerts.finishButton'), this.translate.instant('common.cancel'));
    if (!confirmFinish?.data) {
      return; // User cancelled the initial finish prompt
    }

    this.clearRestTimers();

    // 2. Proceed with routine saving logic after confirmation
    const sessionRoutineValue = this.routine();
    let proceedToLog = true;
    let logAsNewRoutine = false;
    let updateOriginalRoutineStructure = false;
    let newRoutineName = sessionRoutineValue?.name
      ? `${sessionRoutineValue.name} - ${format(new Date(), 'MMM d')}`
      : `Ad-hoc Workout - ${format(new Date(), 'MMM d, HH:mm')}`;

    const originalSnapshot = this.originalRoutineSnapshot();
    const isModifiableRoutine = this.routineId && this.routineId !== '-1';

    if (isModifiableRoutine && originalSnapshot && sessionRoutineValue) {
      const differences = this.comparePerformedToOriginal(loggedExercisesForReport, originalSnapshot.exercises);
      if (differences.majorDifference) {
        const choice = await this.alertService.showConfirmationDialog(
          this.translate.instant('compactPlayer.alerts.routineChangedTitle'), this.translate.instant('compactPlayer.alerts.routineChangedMessage'),
          [
            { text: this.translate.instant('compactPlayer.alerts.logOnly'), role: "log", data: "log", cssClass: "bg-purple-600", icon: 'schedule' } as AlertButton,
            { text: this.translate.instant('compactPlayer.alerts.updateOriginal'), role: "destructive", data: "update", cssClass: "bg-blue-600", icon: 'save' } as AlertButton,
            { text: this.translate.instant('compactPlayer.alerts.saveAsNew'), role: "confirm", data: "new", cssClass: "bg-green-600", icon: 'create-folder' } as AlertButton,
          ],
          { listItems: differences.details }
        );

        if (choice?.data === 'new') {
          const nameInput = await this.alertService.showPromptDialog(this.translate.instant('compactPlayer.alerts.newRoutineNameTitle'), this.translate.instant('compactPlayer.alerts.newRoutineNameMessage'), [{ name: "newRoutineName", type: "text", value: newRoutineName, attributes: { required: true } }], this.translate.instant('compactPlayer.alerts.saveRoutine'));
          if (nameInput && String(nameInput['newRoutineName']).trim()) {
            newRoutineName = String(nameInput['newRoutineName']).trim();
            logAsNewRoutine = true;
          } else proceedToLog = false;
        } else if (choice?.data === 'update') {
          updateOriginalRoutineStructure = true;
        } else if (!choice || choice.data !== 'log') {
          proceedToLog = false;
        }
      }
    } else if (!isModifiableRoutine && loggedExercisesForReport.length > 0) { // Ad-hoc or routineId: -1
      const nameInput = await this.alertService.showPromptDialog(
        this.translate.instant('compactPlayer.alerts.saveAdHocTitle'), this.translate.instant('compactPlayer.alerts.saveAdHocMessage'),
        [{ name: "newRoutineName", type: "text", value: newRoutineName, attributes: { required: true } }],
        this.translate.instant('compactPlayer.alerts.createAndLog'), this.translate.instant('compactPlayer.alerts.logOnly'),
        [{ text: this.translate.instant('compactPlayer.alerts.logWithoutSaving'), role: "no_save", data: "cancel", cssClass: "bg-primary text-white", icon: 'schedule' } as AlertButton], false
      );

      if (nameInput && nameInput['newRoutineName'] && String(nameInput['newRoutineName']).trim()) {
        newRoutineName = String(nameInput['newRoutineName']).trim();
        logAsNewRoutine = true;
      } else if (nameInput && nameInput['role'] === 'no_save') {
        logAsNewRoutine = false;
      } else {
        proceedToLog = false;
      }
    }

    if (!proceedToLog) {
      this.toastService.info(this.translate.instant('compactPlayer.toasts.finishCancelled'), 3000);
      return;
    }

    // 3. Finalize and save the log and routine
    let finalRoutineIdToLog: string | undefined = this.routineId || undefined;
    let finalRoutineNameForLog = sessionRoutineValue?.name || 'Ad-hoc Workout';

    if (logAsNewRoutine) {
      const newRoutineDef: Omit<Routine, 'id'> = {
        name: newRoutineName,
        description: sessionRoutineValue?.description || `Workout from ${format(new Date(), 'MMM d, yyyy')}`,
        goal: sessionRoutineValue?.goal || 'custom',
        exercises: this.convertLoggedToWorkoutExercises(loggedExercisesForReport),
        blocks: this.convertLoggedToWorkoutBlocks(loggedExercisesForReport)
      };
      const createdRoutine = this.workoutService.addRoutine(newRoutineDef);
      finalRoutineIdToLog = createdRoutine.id;
      finalRoutineNameForLog = createdRoutine.name;
      this.toastService.success(this.translate.instant('compactPlayer.toasts.newRoutineCreated', { name: createdRoutine.name }));
    }

    if (updateOriginalRoutineStructure && finalRoutineIdToLog) {
      const routineToUpdate = await firstValueFrom(this.workoutService.getRoutineById(finalRoutineIdToLog).pipe(take(1)));
      if (routineToUpdate) {
        routineToUpdate.exercises = this.convertLoggedToWorkoutExercises(loggedExercisesForReport);
        this.workoutService.updateRoutine(routineToUpdate, true);
        this.toastService.success(this.translate.instant('compactPlayer.toasts.routineUpdated', { name: routineToUpdate.name }));
      }
    }

    log.endTime = Date.now();
    log.durationMinutes = Math.round((log.endTime - (log.startTime!)) / 60000);
    log.exercises = loggedExercisesForReport;
    log.routineId = finalRoutineIdToLog;
    log.routineName = finalRoutineNameForLog;

    if (log.startTime) {
      if (this.program()) log.iterationId = this.program()?.iterationId;

      const savedLog = this.trackingService.addWorkoutLog(log as Omit<WorkoutLog, 'id'> & { startTime: number });
      this.sessionState.set(SessionState.End);
      this.isSessionConcluded = true;
      this.workoutService.removePausedWorkout(false);
      this.timerSub?.unsubscribe();

      if (savedLog.programId) {
        const isProgramCompleted = await this.trainingProgramService.checkAndHandleProgramCompletion(savedLog.programId, savedLog);
        if (isProgramCompleted) {
          this.toastService.success(this.translate.instant('compactPlayer.workoutComplete'), 5000, "Program Finished", false);
          this.router.navigate(['/training-programs/completed', savedLog.programId], { queryParams: { logId: savedLog.id } });
          return;
        }
      }
      if (this.isDestroyed) return;
      this.audioService.playSound(AUDIO_TYPES.tada);
      this.router.navigate(['/workout/summary', savedLog.id], {
        queryParams: { newlyCompleted: 'true' }
      });

    } else {
      this.toastService.error(this.translate.instant('compactPlayer.toasts.saveError'));
    }
  }

  analyzeWorkoutCompletion(): { completedExercises: string[], incompleteExercises: string[], skippedExercises: string[] } {
    const routine = this.routine();
    if (!routine) return { completedExercises: [], incompleteExercises: [], skippedExercises: [] };
    const completed: string[] = [], incomplete: string[] = [], skipped: string[] = [];
    routine.exercises.forEach(ex => {
      const loggedEx = this.currentWorkoutLog().exercises?.find(le => le.id === ex.id);
      const loggedSetCount = loggedEx?.sets.length ?? 0;
      if (loggedSetCount === ex.sets.length) completed.push(ex.exerciseName!);
      else if (loggedSetCount > 0) incomplete.push(ex.exerciseName!);
      else skipped.push(ex.exerciseName!);
    });
    return { completedExercises: completed, incompleteExercises: incomplete, skippedExercises: skipped };
  }

  toggleExerciseActionMenu(exerciseId: string, event: Event) {
    event.stopPropagation();
    this.activeExerciseMenuId.update(current => current === exerciseId ? null : exerciseId);
    this.closeSetActionMenu();
    this.closeMainSessionActionMenu();
  }
  closeExerciseActionMenu() { this.activeExerciseMenuId.set(null); }

  handleExerciseMenuItemClick(event: { actionKey: string, data?: any }) {
    const { actionKey, data: { exerciseId } } = event;
    const setId = this.getWorkoutExerciseById(this.routine(), exerciseId)?.sets[0]?.id ?? '';
    switch (actionKey) {
      case 'exerciseInfo': this.openModal(exerciseId); break;
      case 'switchExercise': this.openSwitchExerciseModal(exerciseId); break;
      case 'insights': this.openPerformanceInsightsModal(exerciseId); break;
      // 'add_round' is now handled by 'addSet'
      case 'addSet': this.addSet(exerciseId); break;
      case 'exerciseNotes': this.toggleExerciseNotes(exerciseId); break;
      case 'removeSet': this.removeSet(exerciseId, setId); break;
      case 'section': this.addSectionExercise(exerciseId); break;
      case 'addWarmupSet': this.addWarmupSet(exerciseId, setId); break;
      case 'remove': this.removeExercise(exerciseId); break;
      case 'createSuperset': this.openCreateSupersetModal(exerciseId); break;
      case 'addToSuperset': this.addToSupersetModal(exerciseId); break;
      // case 'removeFromSuperset': this.removeFromSuperset(exIndex); break;
    }
  }

  createDefaultWarmupSet(workoutExerciseId: string): ExerciseTargetSetParams {
    const routine = this.routine();
    if (!routine) throw new Error('Routine not loaded');
    const exercise = this.getWorkoutExerciseById(this.routine(), workoutExerciseId);
    if (!exercise) throw new Error('Exercise not found');
    const firstSet = exercise.sets[0];

    // Find the base exercise to determine if it's cardio
    const baseExercise = this.availableExercises.find(ex => ex.id === exercise.exerciseId);
    const isCardio = baseExercise?.categories.find(cat => cat === EXERCISE_CATEGORY_TYPES.cardio) !== undefined;

    let warmupMetrics: Partial<ExerciseTargetSetParams>;
    if (!isCardio) {
      warmupMetrics = {
        fieldOrder: [METRIC.weight, METRIC.reps, METRIC.rest],
        targetReps: genRepsTypeFromRepsNumber(12),
        targetWeight: firstSet?.targetWeight ? firstSet.targetWeight : weightToExact(0),
        targetRest: restToExact(30)
      };
    } else {
      warmupMetrics = {
        fieldOrder: [METRIC.duration, METRIC.rest],
        targetDuration: durationToExact(300),
        targetRest: restToExact(30),
      };
    }

    return {
      id: uuidv4(),
      type: 'warmup',
      ...warmupMetrics,
      fieldOrder: warmupMetrics.fieldOrder ?? this.workoutUtilsService.getRepsAndWeightFields()
    };
  }

  addWarmupSet(workoutExerciseId: string, setId: string): void {
    const routine = this.routine();
    if (!routine) return;
    const exercise = this.getWorkoutExerciseById(this.routine(), workoutExerciseId);
    if (!exercise) return;
    // Save old user inputs by index
    const oldInputs: { [key: string]: Partial<ExerciseCurrentExecutionSetParams> } = {};
    exercise.sets.forEach((_, setIndex) => {
      const key = this.getSetKey(workoutExerciseId, setId);
      oldInputs[key] = { ...(this.performanceInputValues()[key] || {}) };
    });

    // Create and insert the new warmup set at the beginning
    const newWarmupSet = this.createDefaultWarmupSet(workoutExerciseId);
    this.routine.update(r => {
      if (!r) return r;
      const newSets = [newWarmupSet, ...exercise.sets];
      const newExercises = r.exercises.map((ex) =>
        ex.id === workoutExerciseId ? { ...ex, sets: newSets } : ex
      );
      return { ...r, exercises: newExercises };
    });

    // Build new performanceInputValues for this exercise
    const updatedExercise = this.getWorkoutExerciseById(this.routine(), workoutExerciseId);
    if (!updatedExercise) return;
    const newInputs = { ...this.performanceInputValues() };

    updatedExercise.sets.forEach((set, setIndex) => {
      const key = this.getSetKey(workoutExerciseId, setId);
      if (setIndex === 0) {
        // New warmup set: default values
        newInputs[key] = {
          actualReps: set.targetReps,
          actualWeight: set.targetWeight,
          actualDistance: set.targetDistance,
          actualDuration: set.targetDuration,
          actualRest: set.targetRest,
          notes: set.notes,
          tempoLogged: set.targetTempo
        };
      } else {
        // Shifted sets: use previous user input if available
        const oldKey = this.getSetKey(workoutExerciseId, exercise.sets[setIndex - 1].id);
        newInputs[key] = oldInputs[oldKey] ?? {
          actualReps: set.targetReps,
          actualWeight: set.targetWeight,
          actualDistance: set.targetDistance,
          actualDuration: set.targetDuration,
          actualRest: set.targetRest,
          notes: set.notes,
          tempoLogged: set.targetTempo
        };
      }
    });

    this.performanceInputValues.set(newInputs);
  }

  addSet(exerciseId: string, type: 'standard' | 'warmup' = 'standard') {
    const routine = this.routine();
    if (!routine) return;

    const triggerExercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!triggerExercise) return;

    // --- CASE 1: Exercise is part of a Superset (Add a new ROUND) ---
    if (this.isExerciseInGroupBlock(exerciseId)) {
      if (type === 'warmup') {
        this.toastService.info("Cannot add a warm-up round to a superset.", 3000);
        return;
      }

      const exercisesInGroup = this.getSupersetExercises(triggerExercise.id);

      exercisesInGroup.forEach(groupEx => {
        const originalGroupExIndex = this.getOriginalExId(groupEx.id);
        if (originalGroupExIndex === '') return;

        const lastSetIndex = groupEx.sets.length > 0 ? groupEx.sets.length - 1 : -1;
        const lastSet = lastSetIndex !== -1 ? groupEx.sets[lastSetIndex] : null;

        // Copy fieldOrder or use default
        const fieldOrder = lastSet?.fieldOrder ? [...lastSet.fieldOrder] : this.workoutUtilsService.getRepsAndWeightFields();

        // Build new set with targets for all metrics in fieldOrder
        const newSet: ExerciseTargetSetParams = {
          id: uuidv4(),
          type: 'standard',
          fieldOrder,
          targetRest: lastSet?.targetRest ?? restToExact(60),
        };

        fieldOrder.forEach(metric => {
          switch (metric) {
            case METRIC.weight:
              newSet.targetWeight = lastSet?.targetWeight ?? weightToExact(10);
              break;
            case METRIC.reps:
              newSet.targetReps = lastSet?.targetReps ?? repsToExact(8);
              break;
            case METRIC.distance:
              newSet.targetDistance = lastSet?.targetDistance ?? distanceToExact(1);
              break;
            case METRIC.duration:
              newSet.targetDuration = lastSet?.targetDuration ?? durationToExact(60);
              break;
            case METRIC.rest:
              newSet.targetRest = lastSet?.targetRest ?? restToExact(60);
              break;
            case METRIC.tempo:
              newSet.targetTempo = lastSet?.targetTempo ?? '';
              break;
          }
        });

        groupEx.sets.push(newSet);
      });

      this.toastService.success(`Round added to ${this.isEmom(triggerExercise.id) ? 'EMOM' : 'Superset'}`);

    } else {
      // --- CASE 2: Standard Exercise ---
      const lastSet = triggerExercise.sets.length > 0 ? triggerExercise.sets[triggerExercise.sets.length - 1] : null;
      const fieldOrder = lastSet?.fieldOrder ? [...lastSet.fieldOrder] : this.workoutUtilsService.getRepsAndWeightFields();

      const newSet: ExerciseTargetSetParams = {
        id: uuidv4(),
        type: type,
        fieldOrder,
        targetRest: lastSet?.targetRest ?? restToExact(60),
      };

      fieldOrder.forEach(metric => {
        switch (metric) {
          case METRIC.weight:
            newSet.targetWeight = lastSet?.targetWeight ?? weightToExact(10);
            break;
          case METRIC.reps:
            newSet.targetReps = lastSet?.targetReps ?? repsToExact(8);
            break;
          case METRIC.distance:
            newSet.targetDistance = lastSet?.targetDistance ?? distanceToExact(1);
            break;
          case METRIC.duration:
            newSet.targetDuration = lastSet?.targetDuration ?? durationToExact(60);
            break;
          case METRIC.rest:
            newSet.targetRest = lastSet?.targetRest ?? restToExact(60);
            break;
          case METRIC.tempo:
            newSet.targetTempo = lastSet?.targetTempo ?? '';
            break;
        }
      });

      if (type === 'warmup') {
        newSet.targetReps = repsToExact(12);
        if (lastSet && lastSet.targetWeight !== undefined && lastSet.targetWeight !== null) {
          newSet.targetWeight = weightToExact(parseFloat((getWeightValue(lastSet.targetWeight) / 2).toFixed(1)));
        } else {
          newSet.targetWeight = weightToExact(0);
        }
        triggerExercise.sets.unshift(newSet);
      } else {
        triggerExercise.sets.push(newSet);
      }
      // this.toastService.success(`${type === 'warmup' ? 'Warm-up set' : 'Set'} added to ${triggerExercise.exerciseName}`);
    }

    this.routine.set({ ...routine });
    if (this.expandedExerciseId() !== exerciseId) {
      this.expandedExerciseId.set(exerciseId);
    }
    this._prefillPerformanceInputs();
  }

  async removeSet(exerciseId: string, setId: string): Promise<void> {
    const routine = this.routine();
    if (!routine) return;

    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return;

    // --- CASE 1: Removing a Superset Round ---
    if (this.isExerciseInGroupBlock(exerciseId)) {
      // Find the round index to remove by matching setId, or default to last round
      const roundIndexToRemove = exercise!.sets.findIndex(set => set.id === setId);
      const validRoundIndex = roundIndexToRemove >= 0 ? roundIndexToRemove : exercise!.sets.length - 1;
      const exercisesInGroup = this.getSupersetExercises(exerciseId);
      // Failsafe: if the exercise is somehow the last in a group and has no sets, treat it as an exercise removal.
      if (exercisesInGroup[0]?.sets.length === 1) {
        const confirmLast = await this.alertService.showConfirm(
          this.translate.instant('compactPlayer.alerts.removeLastRoundTitle'),
          this.translate.instant('compactPlayer.alerts.removeLastRoundMessage'),
          this.translate.instant('actionButtons.removeSuperset'), this.translate.instant('common.cancel')
        );
        if (confirmLast?.data) {
          await this.removeExercise(exerciseId, true); // This now correctly handles removing the whole group
        }
        return;
      }

      const confirm = await this.alertService.showConfirm(
        this.translate.instant('compactPlayer.alerts.removeRoundTitle'),
        this.translate.instant('compactPlayer.alerts.removeRoundMessage', { roundNumber: roundIndexToRemove + 1 }),
      );
      if (!confirm?.data) return;

      // *** ENHANCEMENT 1: More Robust Log Cleanup ***
      // Get the specific plannedSetIds for the round being removed across all exercises in the group.
      const plannedSetIdsForRoundToRemove = exercisesInGroup
        .map(ex => ex.sets[roundIndexToRemove]?.id)
        .filter((id): id is string => !!id);

      // Remove the corresponding logged sets using their unique generated IDs.
      this.currentWorkoutLog.update(log => {
        if (!log.exercises) return log;
        log.exercises.forEach(loggedEx => {
          if (this.isExerciseInGroupBlock(loggedEx.id)) {
            const supersetExercises = this.getSupersetExercises(exercise.id);
            const isInSameBlock = supersetExercises.some(ex => ex.id === loggedEx.id);
            if (isInSameBlock) {
              loggedEx.sets = loggedEx.sets.filter(s => {
                // The unique ID is "{plannedSetId}-round-{roundIndex}"
                const uniqueLoggedId = `${s.plannedSetId?.split('-round-')[0]}`;
                return !plannedSetIdsForRoundToRemove.includes(uniqueLoggedId);
              });
            }
          }
        });
        return { ...log };
      });

      // Update the routine definition by removing the set from each exercise
      this.routine.update(r => {
        if (!r) return r;
        // Re-fetch from the updated routine signal to be safe
        const exercisesInBlock = this.getSupersetExercises(exercise.id);
        exercisesInBlock.forEach(groupEx => {
          const exInRoutine = r.exercises.find(ex => ex.id === groupEx.id);
          if (exInRoutine && exInRoutine.sets.length > roundIndexToRemove) {
            exInRoutine.sets.splice(roundIndexToRemove, 1);
          }
        });
        return { ...r };
      });

      this.toastService.info(this.translate.instant('compactPlayer.toasts.roundRemoved', { roundNumber: roundIndexToRemove + 1 }));
      this.syncRoutineBlocksAfterModification(this.routine()!);
      this.audioService.playSound(AUDIO_TYPES.whoosh);

      return;
    }

    if (!exercise) return;
    const setIndex = this.findCurrentSetIndex(setId) ?? 0;
    // --- CASE 2: Removing a Standard Set (Logic remains the same as it's already robust) ---
    const newSetIndex = setIndex < 0 ? exercise.sets.length - 1 : setIndex;
    const setToRemove = exercise.sets[newSetIndex];
    const isLastSet = exercise.sets.length <= 1;

    let confirmMessage = this.translate.instant('compactPlayer.alerts.removeSetMessage', { name: exercise.exerciseName });
    if (isLastSet) {
      confirmMessage = this.translate.instant('compactPlayer.alerts.removeLastSetMessage');
    }

    const confirm = await this.alertService.showConfirm(this.translate.instant('compactPlayer.alerts.removeSetTitle'), confirmMessage);
    if (!confirm?.data) return;

    // Clear log for this specific set
    this.currentWorkoutLog.update(log => {
      const exerciseLog = log.exercises?.find(e => e.id === exercise.id);
      if (exerciseLog) {
        exerciseLog.sets = exerciseLog.sets.filter(s => s.plannedSetId !== setToRemove.id);
      }
      return { ...log };
    });

    // Remove from routine definition
    exercise.sets.splice(newSetIndex, 1);

    // --- SHIFT performanceInputValues ---
    this.performanceInputValues.update(inputs => {
      // 1. Gather all keys for this exercise
      const keys = Object.keys(inputs)
        .filter(key => key.startsWith(`${exercise.id}-`));
      // 2. Build a new inputs object, shifting down indices after the removed set
      const newInputs: { [key: string]: Partial<ExerciseCurrentExecutionSetParams> } = {};
      // Shift performanceInputValues for all sets after the removed one
      exercise.sets.forEach((set, idx) => {
        // For each remaining set, its new index is its position in the array
        // Find the old set id: if idx >= newSetIndex, the old set was at idx+1, else idx
        let oldSetId: string;
        if (idx >= newSetIndex) {
          // This set was shifted down, so its old id was the next set's id (before removal)
          oldSetId = exercise.sets[idx + 1]?.id;
        } else {
          // This set's id didn't change
          oldSetId = set.id;
        }
        const oldKey = this.getSetKey(exerciseId, oldSetId);
        const newKey = this.getSetKey(exerciseId, set.id);
        if (inputs[oldKey]) {
          newInputs[newKey] = { ...inputs[oldKey] };
        }
      });
      // Remove the deleted set's input
      const removedKey = this.getSetKey(exerciseId, setToRemove.id);
      if (newInputs[removedKey]) {
        delete newInputs[removedKey];
      }
      return { ...inputs, ...newInputs };
    });

    if (exercise.sets.length === 0) {
      this.removeExercise(exerciseId, true);
    } else {
      this.routine.set({ ...routine });
      this.toastService.info(`Set removed from ${exercise.exerciseName}`);
      this.audioService.playSound(AUDIO_TYPES.whoosh);
    }
    this._prefillPerformanceInputs();
  }

  private removeSuperset(exerciseId: string): void {
    const routine = this.routine();
    if (!routine) return;

    const block = this.getBlockForExercise(exerciseId);
    if (!block || block.type === 'single') return;

    // Remove all exercises in the block
    const exerciseIdsToRemove = block.data.exercises.map(ex => ex.id);
    routine.exercises = routine.exercises.filter(ex => !exerciseIdsToRemove.includes(ex.id));

    const log = this.currentWorkoutLog();
    if (log?.exercises) {
      log.exercises = log.exercises.filter(ex => !exerciseIdsToRemove.includes(ex.exerciseId));
    }

    // Sync blocks
    this.workoutService.synchronizeRoutineBlocks(routine);
    this.routine.set({ ...routine });
  }

  private async removeExerciseNoPrompt(exerciseId: string): Promise<void> {
    const routine = this.routine();
    if (!routine) return;
    const exerciseToRemove = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exerciseToRemove) return;

    const shatterable = this.shatterables.find(dir => dir.el.nativeElement.id === `appShatterable-${exerciseToRemove.id}`);
    if (shatterable) {
      shatterable.shatter();
      // Wait for the animation to finish before removing
      await new Promise(res => setTimeout(res, 350));
    }

    // Remove the single exercise from the routine
    this.workoutService.removeExerciseFromBlocks(routine, exerciseId);
    this.routine.set({ ...routine });

    // Remove the single corresponding exercise from the log
    this.currentWorkoutLog.update(log => {
      if (log.exercises) {
        const logExIndex = log.exercises.findIndex(le => le.id === exerciseToRemove.id);
        if (logExIndex > -1) {
          log.exercises.splice(logExIndex, 1);
        }
      }
      return { ...log };
    });

    // --- Remove all performanceInputValues for this exercise ---
    this.performanceInputValues.update(inputs => {
      const updated = { ...inputs };
      Object.keys(updated).forEach(key => {
        if (key.startsWith(`${exerciseToRemove.id}-`)) {
          delete updated[key];
        }
      });
      return updated;
    });

    this._prefillPerformanceInputs();
    this.toastService.info(`${exerciseToRemove.exerciseName} ${this.translate.instant('common.removed')}`);
    this.audioService.playSound(AUDIO_TYPES.whoosh);
  }



  async removeExercise(exerciseId: string, confirmRequest: boolean = false): Promise<void> {
    const routine = this.routine();
    if (!routine) return;

    const exerciseToRemove = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exerciseToRemove) return;
    const isInGroup = this.isExerciseInGroupBlock(exerciseId);

    // Find the shatterable directive for this exercise card
    const shatterable = this.shatterables.find(dir => dir.el.nativeElement.id === `appShatterable-${exerciseToRemove.id}`);

    // --- CASE 0: Forcely removing an entire Superset group / exercise ---
    if (confirmRequest) {
      if (shatterable) {
        shatterable.shatter();
        // Wait for the animation to finish before removing
        await new Promise(res => setTimeout(res, 350));
      }
      if (isInGroup) {
        this.removeSuperset(exerciseId);
      } else {
        this.removeExerciseNoPrompt(exerciseId);
      }
      return;
    }

    // --- CASE 1: Removing an entire Superset group ---
    if (isInGroup) {
      const supersetName = this.getSupersetDisplayName(exerciseId);
      const confirm = await this.alertService.showConfirm(
        this.translate.instant("compactPlayer.alerts.removeSupersetTitle"),
        this.translate.instant("compactPlayer.alerts.removeSupersetMessage", { name: supersetName }),
        this.translate.instant("compactPlayer.alerts.removeSupersetTitle"),
        this.translate.instant("common.cancel")
      );

      if (!confirm?.data && !confirmRequest) return;

      if (shatterable) {
        shatterable.shatter();
        // Wait for the animation to finish before removing
        await new Promise(res => setTimeout(res, 350));
      }

      this.removeSuperset(exerciseId);
      return;

    } else {
      // --- CASE 2: Removing a Standard (standalone) Exercise ---
      // Only ask for confirmation if the exercise has at least one logged set
      const isExerciseLogged = this.isExerciseLogged(exerciseId);
      const confirmMessage = isExerciseLogged
        ? this.translate.instant('compactPlayer.alerts.removeExerciseLoggedMessage', { name: exerciseToRemove.exerciseName })
        : this.translate.instant('compactPlayer.alerts.removeExerciseMessage', { name: exerciseToRemove.exerciseName });

      const confirm = await this.alertService.showConfirm(this.translate.instant('compactPlayer.alerts.removeExerciseTitle'), confirmMessage);

      if (confirm?.data) {
        this.removeExerciseNoPrompt(exerciseId);
      }
    }
  }

  private loadAvailableExercises(): void {
    this.exerciseService.getExercises().pipe(
      take(1),
      // Use switchMap to chain the translation call after fetching the base list
      switchMap(exercises => this.exerciseService.getTranslatedExerciseList(exercises))
    ).subscribe(translatedExercises => {
      // Now, the exercises in the list have their translated names
      this.availableExercises = translatedExercises.filter(ex => !ex.isHidden);
      this.defaultExercises = translatedExercises.filter(ex => !ex.isHidden);
    });
  }

  /**
   * Takes a routine and returns an Observable that emits a new routine
   * with all exercise names translated.
   * @param routine The routine to translate.
   * @returns An Observable of the translated Routine.
   */
  private translateRoutineExercises$(routine: Routine): Observable<Routine> {
    // If there's nothing to translate, return the original routine immediately
    if (!routine || !routine.exercises || routine.exercises.length === 0) {
      return of(routine);
    }

    // Create an array of Observables, each handling one exercise's translation
    const translationObservables = routine.exercises.map(workoutEx =>
      this.exerciseService.getWorkoutExerciseById(workoutEx.exerciseId).pipe(
        switchMap(baseExercise => {
          // If the base exercise can't be found, proceed with the original workout exercise
          if (!baseExercise) return of(workoutEx);
          // Otherwise, get the translated version
          return this.exerciseService.getTranslatedExercise(baseExercise);
        }),
        map((translatedBaseExercise: any) => {
          // Return a new workout exercise object with the translated name
          // Note: If translation failed, translatedBaseExercise will be the original, so the name remains correct
          return {
            ...workoutEx,
            exerciseName: translatedBaseExercise.name
          };
        }),
        take(1) // Ensure each inner observable completes
      )
    );

    // Use forkJoin to wait for all translations to complete
    return forkJoin(translationObservables).pipe(
      map(translatedExercises => {
        // Return a new routine object containing the array of translated exercises
        return {
          ...routine,
          exercises: translatedExercises
        };
      })
    );
  }


  openAddExerciseModal(): void { this.isAddExerciseModalOpen.set(true); }
  closeAddExerciseModal(): void {
    this.isAddExerciseModalOpen.set(false);
    this.modalSearchTerm.set('');
  }

  openSwitchExerciseModal(exerciseId: string): void {
    this.exerciseToSwitchId.set(exerciseId);

    // Set the initial list for the modal to the full, searchable list
    this.exercisesForSwitchModal.set(this.availableExercises);

    this.isSwitchExerciseModalOpen.set(true);
    this.isShowingSimilarInSwitchModal.set(false); // Ensure we start in search mode
    this.modalSearchTerm.set('');
  }
  closeSwitchExerciseModal(): void {
    this.isSwitchExerciseModalOpen.set(false);
    this.isShowingSimilarInSwitchModal.set(false);
    this.exerciseToSwitchId.set(null);
    this.modalSearchTerm.set('');
  }

  async openPerformanceInsightsModal(exerciseId: string): Promise<void> {
    const routine = this.routine();
    if (!routine) return;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return;
    const baseExercise$ = this.exerciseService.getWorkoutExerciseById(exercise.exerciseId).pipe(take(1));
    const lastPerformance$ = this.trackingService.getLastPerformanceForExercise(exercise.exerciseId).pipe(take(1));
    const personalBests$ = this.trackingService.getAllPersonalBestsForExercise(exercise.exerciseId).pipe(take(1));
    try {
      const [baseExercise, lastPerformance, personalBests] = await Promise.all([
        lastValueFrom(baseExercise$),
        lastValueFrom(lastPerformance$),
        lastValueFrom(personalBests$)
      ]);
      if (!baseExercise) {
        return;
      }
      const completedSets = this.currentWorkoutLog().exercises?.find(e => e.id === exercise.id)?.sets || [];
      this.insightsData.set({ exercise, baseExercise, lastPerformance, personalBests, completedSetsInSession: completedSets });
      this.isPerformanceInsightsModalOpen.set(true);
    } catch (error) {
      console.error("Failed to load performance insights:", error);
      this.toastService.error("Could not load performance data.");
    }
  }

  closePerformanceInsightsModal(): void {
    this.isPerformanceInsightsModalOpen.set(false);
    this.insightsData.set(null);
  }

  async handleTrulyCustomExerciseEntry(): Promise<void> {
    this.closeAddExerciseModal();
    const currentRoutineVal = this.routine();
    if (!currentRoutineVal) { return; }
    const newCustomExercise: Exercise = {
      id: `custom-adhoc-ex-${uuidv4()}`,
      name: 'Custom exercise',
      description: '', categories: [EXERCISE_CATEGORY_TYPES.custom], muscleGroups: [], primaryMuscleGroup: undefined, imageUrls: []
    };
    await this.selectExerciseToAddFromModal(newCustomExercise);
  }

  async selectExerciseToAddFromModal(selectedExercise: Exercise): Promise<void> {
    this.closeAddExerciseModal();
    const routine = this.routine();
    if (!routine) {
      this.toastService.error("Cannot add exercise: routine data unavailable.", 0, "Error");
      return;
    }

    const log = this.currentWorkoutLog();
    const allLoggedExercises = log.exercises || [];
    const lastLoggedExercise = allLoggedExercises.length > 0 ? allLoggedExercises[allLoggedExercises.length - 1] : null;
    const lastLoggedSet = lastLoggedExercise && lastLoggedExercise.sets.length > 0 ? lastLoggedExercise.sets[lastLoggedExercise.sets.length - 1] : null;

    const newWorkoutExercise = await this.workoutService.promptAndCreateWorkoutExercise(selectedExercise, lastLoggedSet);

    if (newWorkoutExercise) {
      if (selectedExercise.id.startsWith('custom-adhoc-ex-')) {
        const newExerciseToBeSaved = this.exerciseService.mapWorkoutExerciseToExercise(newWorkoutExercise, selectedExercise);
        this.exerciseService.addExercise(newExerciseToBeSaved);
      }
      this.addExerciseToRoutine(newWorkoutExercise);
    }
  }

  addExerciseToRoutine(newWorkoutExercise: WorkoutExercise): void {
    this.routine.update(r => {
      // If the routine doesn't exist, we can't add to it.
      if (!r) return r;

      // Use block-first helper to add exercise
      this.workoutService.addExerciseToBlocksRoutine(r, newWorkoutExercise);
      return r;
    });

    // We now set the expanded index *after* the update has been processed.
    // Use an effect or a simple timeout to ensure the DOM has time to react.
    // Initialize performanceInputValues for the new exercise's sets
    setTimeout(() => {
      const routine = this.routine();
      if (!routine) return;
      const newIndex = routine.exercises.length - 1;
      const exercise = routine.exercises[newIndex];
      const newInputs = { ...this.performanceInputValues() };
      exercise.sets.forEach((set, setIndex) => {
        const key = this.getSetKey(exercise.id, set.id);
        newInputs[key] = {
          actualReps: set.targetReps,
          actualWeight: set.targetWeight,
          actualDistance: set.targetDistance,
          actualDuration: set.targetDuration,
          actualRest: set.targetRest,
          notes: set.notes,
          tempoLogged: set.targetTempo
        };
      });
      this.performanceInputValues.set(newInputs);
      this.expandedExerciseId.set(exercise.sets[exercise.sets.length - 1].id);
    }, 0);

    this.closeAddExerciseModal();
    // this._prefillPerformanceInputs();
  }

  handleExerciseSwitch(newExercise: Exercise) {
    const exerciseId = this.exerciseToSwitchId();
    if (exerciseId === null) return;

    this.routine.update(r => {
      if (r) {
        const oldWorkoutExercise = r.exercises.find(ex => ex.id === exerciseId);
        if (!oldWorkoutExercise) return;
        const oldExerciseName = oldWorkoutExercise.exerciseName;

        const oldBaseExercise = this.availableExercises.find(ex => ex.id === oldWorkoutExercise.exerciseId);
        const newBaseExercise = this.availableExercises.find(ex => ex.id === newExercise.id);

        if (oldBaseExercise && newBaseExercise && oldBaseExercise.categories !== newBaseExercise.categories) {
          this.toastService.info(`Switching exercise type. Set data will be reset.`, 3000);
          oldWorkoutExercise.sets.forEach(set => {
            if (newBaseExercise.categories.find(cat => cat === EXERCISE_CATEGORY_TYPES.cardio) !== undefined) {
              set.targetWeight = undefined;
              set.targetReps = undefined;
              set.targetDistance = set.targetDistance ?? distanceToExact(1); // Default cardio values
              set.targetDuration = set.targetDuration ?? durationToExact(300);
            } else { // Assuming switch to strength or other non-cardio
              set.targetDistance = undefined;
              set.targetDuration = undefined;
              set.targetWeight = set.targetWeight ?? weightToExact(10); // Default strength values
              set.targetReps = set.targetReps ?? genRepsTypeFromRepsNumber(8);
            }
          });
        }

        oldWorkoutExercise.exerciseId = newExercise.id;
        oldWorkoutExercise.exerciseName = newExercise.name;

        this.toastService.success(`Switched ${oldExerciseName} with ${newExercise.name}`);
      }
      return r;
    });
    this.closeSwitchExerciseModal();
  }

  formatPbValue(pb: PersonalBestSet): string {
    if (pb.weightLogged != null && getWeightValue(pb.weightLogged) > 0) {
      let value = this.weightUnitPipe.transform(getWeightValue(pb.weightLogged));
      if (pb.repsLogged && repsTypeToReps(pb.repsLogged) > 1) value += ` x ${this.getRepsValue(pb.repsLogged)}`;
      return value || 'N/A';
    }
    if (pb.repsLogged) return `${this.getRepsValue(pb.repsLogged)} reps`;
    if (pb.durationLogged) return `${this.getDurationValue(pb.durationLogged)}s`;
    return 'N/A';
  }

  async findAndShowSimilarExercises(exerciseToSwitchIndex: string | null): Promise<void> {
    if (exerciseToSwitchIndex === null) return;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseToSwitchIndex);
    if (!exercise) return;

    let baseExercise = this.availableExercises.find(ex => ex.id === exercise.exerciseId);
    if (!baseExercise) {
      baseExercise = await lastValueFrom(this.exerciseService.getWorkoutExerciseById(exercise.exerciseId).pipe(take(1)));
      if (!baseExercise) {
        this.toastService.error("Could not load details for the current exercise.");
        return;
      }
    }
    try {
      const similar = await lastValueFrom(this.exerciseService.getSimilarExercises(baseExercise, 12).pipe(take(1)));
      if (similar.length === 0) this.toastService.info("No similar exercises found.");

      // Overwrite the modal's list with the new 'similar' list
      this.exercisesForSwitchModal.set(similar);
      this.isShowingSimilarInSwitchModal.set(true); // Switch the view mode

    } catch (error) {
      this.toastService.error("Could not load similar exercises.");
    }
  }

  onBackToSearchFromSimilar(): void {
    // Reset the modal's list back to the full, searchable list
    this.exercisesForSwitchModal.set(this.availableExercises);
    this.isShowingSimilarInSwitchModal.set(false); // Switch the view mode back
    this.modalSearchTerm.set('');
  }

  toggleCompletedSetsForExerciseInfo(): void { this.showCompletedSetsForExerciseInfo.update(v => !v); }
  toggleCompletedSetsForDayInfo(): void { this.showCompletedSetsForDayInfo.update(v => !v); }

  areActionsVisible(exerciseId: string): boolean {
    return this.activeExerciseMenuId() === exerciseId;
  }

  toggleMainSessionActionMenu(event: Event | null) {
    event?.stopPropagation();
    this.mainSessionActionMenuOpened.update(current => current === true ? false : true);
    this.closeExerciseActionMenu();
    this.closeSetActionMenu();
  }

  closeMainSessionActionMenu() {
    this.mainSessionActionMenuOpened.set(false);
  }

  protected menuButtonBaseClass = computed(() => {
    const isModalMenu = this.appSettingsService.isMenuModeModal();
    const isCompactMenu = this.appSettingsService.isMenuModeCompact();
    // This is the common part for all buttons, if they need special modal styling
    return isModalMenu ? " w-full flex justify-start items-center text-black dark:text-white hover:text-white text-left px-4 py-2 rounded-md text-xl font-medium " : '';
  });

  isCalculatorModalVisible: boolean = false;
  openCalculatorModal(): void {
    this.isCalculatorModalVisible = true;
  }

  closeCalculatorModal(): void {
    this.isCalculatorModalVisible = false;
  }

  mainSessionActionItems = computed<ActionMenuItem[]>(() => {
    // Read dependencies once at the beginning of the computed function
    const isPaused = this.sessionState() === 'paused';
    const hasExercises = (this.routine()?.exercises?.length ?? 0) > 0;
    const commonModalButtonClass = this.menuButtonBaseClass(); // Use the new computed property
    const addExerciseDisabledClass = (isPaused || !hasExercises ? 'disabled ' : '');

    const barbellCalculatorBtn = {
      actionKey: 'weight_toolkit',
      iconName: 'dumbbell',
      buttonClass: 'bg-yellow-800'
    } as ActionMenuItem;

    const actions: ActionMenuItem[] = [
      {
        ...(isPaused ? resumeSessionBtn : pauseSessionBtn),
        overrideCssButtonClass: (isPaused ? resumeSessionBtn.buttonClass : pauseSessionBtn.buttonClass) + commonModalButtonClass
      },
      {
        ...sessionNotesBtn,
        overrideCssButtonClass: sessionNotesBtn.buttonClass + commonModalButtonClass
      },
      {
        ...timerBtn,
        label: this.translate.instant('compactPlayer.rest'),
        overrideCssButtonClass: timerBtn.buttonClass + commonModalButtonClass
      },
      {
        ...addExerciseBtn,
        overrideCssButtonClass: addExerciseDisabledClass + addExerciseBtn.buttonClass + commonModalButtonClass
      },
      {
        ...calculatorBtn,
        overrideCssButtonClass: calculatorBtn.buttonClass + commonModalButtonClass
      },
      { isDivider: true },
      {
        ...quitWorkoutBtn,
        overrideCssButtonClass: quitWorkoutBtn.buttonClass + commonModalButtonClass
      },
    ];

    return actions;
  });


  handleMainSessionActionMenuItemClick(event: { actionKey: string, data?: any }) {
    const { actionKey } = event;
    switch (actionKey) {
      case 'pause': this.pauseSession(); break;
      case 'weight_toolkit': this.openCalculatorModal(); break;
      case 'play': this.resumeSession(); break;
      case 'session_notes': this.editSessionNotes(); break;
      case 'addExercise': this.openAddExerciseModal(); break;
      case 'exit': this.quitWorkout(); break;
      case 'timer': this.openManualRestTimer(); break;
    }
  }

  clearRestTimers(): void {
    clearInterval(this.compactRestInterval);
    this.compactRestInterval = null;
    this.restStartTimestamps = {};
    this.lastCompactRestBeepSecond = null;
  }

  async quitWorkout(): Promise<void> {
    const confirmQuit = await this.alertService.showConfirm(this.translate.instant('compactPlayer.alerts.quitTitle'), this.translate.instant('compactPlayer.alerts.quitMessage'));
    if (confirmQuit && confirmQuit.data) {
      this.isSessionConcluded = true;
      this.sessionState.set(SessionState.End);
      this.toggleMainSessionActionMenu(null);
      this.clearRestTimers();
      this.toastService.info(this.translate.instant('compactPlayer.toasts.noSetsLoggedError'), 4000);
      this.router.navigate(['/home']);
    }
  }

  private isExerciseFullyLogged(currentExercise: WorkoutExercise): boolean {
    const loggedEx = this.currentWorkoutLog().exercises?.find(le => le.id === currentExercise.id);
    if (!loggedEx) return false;
    // Total planned completions is simply the number of sets.
    return loggedEx.sets.length >= currentExercise.sets.length;
  }


  private isExercisePartiallyLogged(currentExercise: WorkoutExercise): boolean {
    const loggedEx = this.currentWorkoutLog().exercises?.find(le => le.id === currentExercise.id);
    if (!loggedEx || loggedEx.sets.length === 0) return false;
    // Check against the total number of sets.
    const totalPlannedCompletions = currentExercise.sets.length;
    return loggedEx.sets.length > 0 && loggedEx.sets.length < totalPlannedCompletions;
  }

  exerciseActionItemsMap = computed<Map<string, ActionMenuItem[]>>(() => {
    const map = new Map<string, ActionMenuItem[]>();
    const routine = this.routine(); // Read the dependency signal once
    const commonModalButtonClass = this.menuButtonBaseClass();

    if (!routine) {
      return map; // Return an empty map if there's no routine
    }

    // Loop through each exercise and build its specific action item array
    routine.exercises.forEach((exercise) => {
      // Create new objects using spread and concatenate class strings
      const currSwitchExerciseBtn = {
        ...switchExerciseBtn,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: switchExerciseBtn.buttonClass + commonModalButtonClass
      };
      const currExerciseInfoBtn = {
        ...exerciseInfoBtn,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: exerciseInfoBtn.buttonClass + commonModalButtonClass
      };
      const addSectionExerciseBtn = {
        ...sectionExerciseBtn,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: sectionExerciseBtn.buttonClass + commonModalButtonClass
      }
      const currOpenPerformanceInsightsBtn = {
        ...openSessionPerformanceInsightsBtn,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: openSessionPerformanceInsightsBtn.buttonClass + commonModalButtonClass
      };
      const addExerciseNotesBtn: ActionMenuItem = {
        ...exerciseNotesBtn,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: exerciseNotesBtn.buttonClass + commonModalButtonClass
      };

      const baseAddSetRoundBtn = !this.isSuperSet(exercise.id) ? addSetToExerciseBtn : { ...addRoundToExerciseBtn, actionKey: 'addSet' };

      const addWarmupSetBtnItem = {
        ...addWarmupSetBtn,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: addWarmupSetBtn.buttonClass + commonModalButtonClass
      };

      const removeExerciseBtnItem = {
        ...removeExerciseBtn,
        label: this.isSuperSet(exercise.id) ? 'actionButtons.removeSuperset' : removeExerciseBtn.label,
        data: { exerciseId: exercise.id },
        overrideCssButtonClass: removeExerciseBtn.buttonClass + commonModalButtonClass
      } as ActionMenuItem;

      let actionsArray: ActionMenuItem[] = [
        currExerciseInfoBtn,
        currOpenPerformanceInsightsBtn,
        addExerciseNotesBtn,
        addSectionExerciseBtn
      ];

      if (!this.isExercisePartiallyLogged(exercise) && !this.isExerciseFullyLogged(exercise) && !this.isSuperSet(exercise.id)) {
        actionsArray.push(addWarmupSetBtnItem as ActionMenuItem);
        actionsArray.push(currSwitchExerciseBtn as ActionMenuItem);
      }

      actionsArray = [...actionsArray,
      { isDivider: true },
        removeExerciseBtnItem,
      ];

      // RULE 1: "Remove from Superset" - UPDATED: Use block-aware check
      if (this.isExerciseInGroupBlock(exercise.id)) {
        // Exercise is in a group block - commented out as per original logic
        // actionsArray.push({
        //   ...removeFromSuperSetBtn,
        //   data: { exIndex },
        //   overrideCssButtonClass: removeFromSuperSetBtn.buttonClass + commonModalButtonClass
        // } as ActionMenuItem);
      } else {
        // RULES 2 & 3: "Add to" and "Create Superset"
        if (routine.exercises.length >= 2) {
          // Find all group blocks in the routine (exercises that are in groups)
          const exercisesInGroups = routine.exercises.filter(ex => this.isExerciseInGroupBlock(ex.id));

          // Find if there is AT LEAST ONE group block where NO exercises have any logged sets
          let hasUnloggedGroupBlock = false;

          // Get unique blocks by checking which exercises share block membership
          const processedBlocks = new Set<string>();
          exercisesInGroups.forEach(groupExercise => {
            const block = this.getBlockForExercise(groupExercise.id);
            if (block && block.type === 'group') {
              const blockKey = block.data.exercises.map(ex => ex.id).sort().join('-');
              if (!processedBlocks.has(blockKey)) {
                processedBlocks.add(blockKey);

                // Check if ALL exercises in this block have NO logged sets
                const allNotLogged = block.data.exercises.every(blockEx => {
                  const loggedEx = this.currentWorkoutLog()?.exercises?.find(le => le.id === blockEx.id);
                  return !loggedEx || loggedEx.sets.length === 0;
                });

                if (allNotLogged) {
                  hasUnloggedGroupBlock = true;
                }
              }
            }
          });

          // Add the button ONLY ONCE if there's at least one unlogged group block
          if (hasUnloggedGroupBlock) {
            actionsArray.push({
              ...addToSuperSetBtn,
              data: { exerciseId: exercise.id },
              overrideCssButtonClass: addToSuperSetBtn.buttonClass + commonModalButtonClass
            });
          }

          // Add "Create Superset" button if there are at least 2 non-group exercises
          const standaloneExercises = routine.exercises.filter(ex => !this.isExerciseInGroupBlock(ex.id));
          if (standaloneExercises.length >= 2) {
            actionsArray.push({
              ...createSuperSetBtn,
              data: { exerciseId: exercise.id },
              overrideCssButtonClass: createSuperSetBtn.buttonClass + commonModalButtonClass
            });
          }
        }
      }

      // Set the generated array in the map with the exercise's index as the key
      map.set(exercise.id, actionsArray);
    });

    return map;
  });

  get exerciseToSwitchIndex(): number | null {
    const routine = this.routine();
    const exerciseId = this.exerciseToSwitchId();
    if (!routine || !exerciseId) return null;
    const idx = this.getExerciseIndexById(routine, exerciseId);
    return idx !== -1 ? idx : null;
  }

  /**
   * Returns the index of the currently expanded exercise, or -1 if none is expanded.
   */
  get expandedExerciseIndex(): number {
    const routine = this.routine();
    const expandedId = this.expandedExerciseId();
    if (!routine || !expandedId) return -1;
    return this.getExerciseIndexById(routine, expandedId);
  }

  private async startRestPeriod(
    exerciseId: string, plannedSetId: string, duration: number): Promise<void> {
    this.playerSubState.set(PlayerSubState.Resting);
    this.restTimerMode.set(TIMER_MODES.timer);
    this.restDuration.set(duration);
    this.restTimerMainText.set(this.translate.instant('compactPlayer.rest'));
    this.restTimerNextUpText.set('Loading next set...');
    this.restTimerNextSetDetails.set(null);

    if (this.getRestTimerMode() === this.restTimerModeEnum.Fullscreen) {
      this.isRestTimerVisible.set(true);
    }

    if (this.getRestTimerMode() === this.restTimerModeEnum.Compact) {
      const restKey = this.getSetKey(exerciseId, plannedSetId);
      this.restStartTimestamps[restKey] = Date.now();
      this.lastCompactRestBeepSecond = null;
      if (this.compactRestInterval) clearInterval(this.compactRestInterval);
      this.compactRestInterval = setInterval(() => {
        const remaining = this.restTimerRemainingForSet(exerciseId, plannedSetId);
        // Play countdown sound for last 5 seconds
        const countDownSoundEnabled: boolean = !!(this.appSettingsService.enableTimerCountdownSound() && this.appSettingsService.getSettings().countdownSoundSeconds);
        const countDownSoundNumber: number = countDownSoundEnabled ? this.appSettingsService.getSettings().countdownSoundSeconds : 0;

        if (remaining > 0 && countDownSoundNumber && remaining <= countDownSoundNumber && remaining !== this.lastCompactRestBeepSecond) {
          this.playCountdownSound(remaining);
          this.lastCompactRestBeepSecond = remaining;
        }
        // Play end sound and clear interval when done
        if (remaining === 0) {
          this.playEndSound();
          clearInterval(this.compactRestInterval);
          this.compactRestInterval = null;
          this.lastCompactRestBeepSecond = null;
        }
      }, 250); // Check 4 times per second for responsiveness
    }

    const nextStep = await this.peekNextStepInfo(exerciseId, plannedSetId);

    if (!nextStep.exercise || !nextStep.details) {
      this.restTimerNextUpText.set("Workout Complete!");
      this.restTimerNextSetDetails.set(null);
      return;
    }

    const { exercise, details: plannedSet, historicalSet } = nextStep;
    const nextExIndex = this.getOriginalExId(exercise.id);
    const nextSetIndex = exercise.sets.indexOf(plannedSet);

    // --- CASE 1: The next item is part of a Superset (No changes here) ---
    if (this.isExerciseInGroupBlock(exerciseId)) {
      const roundIndex = exercise.sets.indexOf(plannedSet);
      const exercisesInGroup = this.getSupersetExercises(exerciseId);
      const totalRounds = exercisesInGroup.length > 0 ? exercisesInGroup[0].sets.length : 0;

      let titleLine: string;
      const blockType = this.getBlockType(exerciseId);
      if (blockType === 'emom') {
        const block = this.getBlockForExercise(exerciseId);
        const emomTime = block?.type === 'group' ? block.data.config?.emomInterval || 60 : 60;
        titleLine = `EMOM: Round ${roundIndex + 1}/${totalRounds} (Every ${emomTime}s)`;
      } else {
        titleLine = `Next Up: Round ${roundIndex + 1}/${totalRounds}`;
      }

      const detailLines = exercisesInGroup.map(groupEx => {
        const setForThisRound = groupEx.sets[roundIndex];
        if (!setForThisRound) return '';

        const originalExIndex = this.getOriginalExId(groupEx.id);
        const displayIndex = this.getExerciseDisplayIndex(groupEx.id, true);
        const exName = groupEx.exerciseName;
        const targetDetails = this.formatSetTargetForDisplay(setForThisRound, groupEx, originalExIndex, plannedSetId);

        return `<div class="flex items-start gap-3 mt-3">
                    <span class="font-bold text-gray-400 dark:text-gray-300 w-8 text-center">${displayIndex}</span>
                    <div class="flex-1 text-left">
                        <p class="font-semibold text-gray-800 dark:text-white">${exName}</p>
                        <p class="text-sm text-gray-500 dark:text-gray-400">${targetDetails}</p>
                    </div>
                </div>`;
      }).join('');

      this.restTimerNextUpText.set(`<div class="text-left"><p class="text-lg font-bold">${titleLine}</p></div><div class="mt-2">${detailLines}</div>`);

    } else {
      // =================== START OF MODIFICATION ===================
      // --- CASE 2: The next item is a Standard Exercise ---
      const line1 = exercise.exerciseName;
      const setIndex = exercise.sets.indexOf(plannedSet);
      const line2 = `Set ${setIndex + 1}/${exercise.sets.length}`;

      // --- Historical (Volta precedente) ---
      let historicalLine = '';
      if (historicalSet) {
        const parts: string[] = [];
        const weightValue = this.workoutUtilsService.getWeightValue(historicalSet.weightLogged);
        const repsValue = this.workoutUtilsService.getRepsValue(historicalSet.repsLogged);
        if (weightValue != undefined && repsValue != undefined) {
          const weight = this.weightUnitPipe.transform(weightValue);
          parts.push(`${weight} x ${repsValue} reps`);
        } else if (repsValue != undefined) {
          parts.push(`${repsValue} reps`);
        }
        const durationValue = this.workoutUtilsService.getDurationValue(historicalSet.durationLogged);
        if (durationValue != undefined && durationValue > 0) {
          parts.push(this.formatSecondsToTime(durationValue));
        }
        const distanceValue = this.workoutUtilsService.getDistanceValue(historicalSet.distanceLogged);
        if (distanceValue != undefined && distanceValue > 0) {
          parts.push(`${distanceValue} ${this.unitsService.getDistanceUnitSuffix()}`);
        }
        if (parts.length > 0) {
          // Add date if available
          let dateStr = '';
          if (historicalSet?.timestamp) {
            const date = new Date(historicalSet.timestamp);
            dateStr = ` (${date.toLocaleDateString()})`;
          }
          historicalLine = `${this.translate.instant('restTimer.lastTime')}: ${parts.join(' | ')}${dateStr}`;
        }
      }

      // --- Next Set Target ---
      const targetParts: string[] = [];
      const repsDisplay = this.workoutUtilsService.getSetTargetDisplay(plannedSet, METRIC.reps);
      const weightDisplay = this.workoutUtilsService.getSetWeightDisplay(plannedSet, exercise);
      if (repsDisplay && repsDisplay !== '0' && weightDisplay !== this.translate.instant('workoutService.display.weightNotApplicable')) {
        targetParts.push(`${weightDisplay} x ${repsDisplay} reps`);
      }
      const durationDisplay = this.workoutUtilsService.getSetTargetDisplay(plannedSet, METRIC.duration);
      if (durationDisplay && durationDisplay !== '0' && this.formatSecondsToTime(durationDisplay) !== '00:00') {
        targetParts.push(`<span class="inline-flex items-center">${this.formatSecondsToTime(durationDisplay)} mm:ss</span>`);
      }
      const distanceDisplay = this.workoutUtilsService.getSetTargetDisplay(plannedSet, METRIC.distance);
      if (distanceDisplay && distanceDisplay !== '0') {
        targetParts.push(`${distanceDisplay} ${this.unitsService.getDistanceUnitSuffix()}`);
      }
      let targetLine = '';
      if (targetParts.length > 0) {
        targetLine = `${this.translate.instant('restTimer.target')}: ${targetParts.join(' | ')}`;
      } else {
        targetLine = this.translate.instant('restTimer.noTarget');
      }

      // --- Compose the final text ---
      // let nextUpHtml = `<div><span class="font-bold">${this.translate.instant('restTimer.nextUp')}</span></div>`;
      let nextUpHtml = ``;
      nextUpHtml += `<div class="font-semibold">${line1}</div>`;
      nextUpHtml += `<div class="text-base opacity-80">${line2}</div>`;
      nextUpHtml += `<div class="text-base font-bold">${targetLine}</div>`;
      if (historicalLine) {
        nextUpHtml += `<div class="text-base font-normal opacity-80">${historicalLine}</div>`;
      }

      this.restTimerNextUpText.set(nextUpHtml);
      // =================== END OF MODIFICATION ===================
    }

    this.restTimerNextSetDetails.set(nextStep.details);
  }

  /**
 * Smoothly scrolls the viewport to a specific set card within an exercise.
 * @param exerciseId: string The id of the parent exercise.
 * @param setId The id of the target set.
 */
  private scrollToSet(exerciseId: string, setId: string): void {
    // This logic needs to run after the DOM has updated with the newly expanded set.
    runInInjectionContext(this.injector, () => {
      afterNextRender(() => {
        requestAnimationFrame(() => {
          const cardElement = document.querySelector(`[data-exercise-id="${exerciseId}"]`) as HTMLElement;
          const setElement = cardElement?.querySelector(`[data-set-id="${setId}"]`) as HTMLElement;
          const headerElement = this.header?.nativeElement;

          // This logic scrolled too much
          // if (setElement && headerElement) {
          //   const headerHeight = headerElement.offsetHeight;
          //   const elementTopPosition = setElement.getBoundingClientRect().top + window.scrollY;
          //   const scrollTopPosition = elementTopPosition - headerHeight - 15; // 15px top padding
          //   window.scrollTo({ top: scrollTopPosition, behavior: 'smooth' });
          // }
          this.scrollCurrentElementIntoView(undefined, setId);
        });
      });
    });
  }

  scrollCurrentElementIntoView(exerciseId: string | undefined, setId: string | undefined): void {
    const exerciseSelector = `[data-exercise-id="${exerciseId}"]`;
    const setSelector = `[data-set-id="${setId}"]`;
    let element = null;
    if (setId !== undefined) {
      element = document.querySelector(setSelector) as HTMLElement | null;
    } else {
      element = document.querySelector(exerciseSelector) as HTMLElement | null;
    }
    if (element && typeof element.scrollIntoView === 'function') {
      element.scrollIntoView({
        behavior: 'smooth',
        block: 'center',
      });
    }
  }

  /**
   * Smoothly scrolls the viewport to a specific round card within a superset.
   * @param exerciseId The id of the parent exercise that starts the superset.
   * @param roundId The id of the target round.
   */
  private scrollToRound(exerciseId: string, roundId: string): void {
    runInInjectionContext(this.injector, () => {
      afterNextRender(() => {
        requestAnimationFrame(() => {
          const cardElement = document.querySelector(`[data-exercise-id="${exerciseId}"]`) as HTMLElement;
          const roundElement = cardElement?.querySelector(`[data-round-id="${roundId}"]`) as HTMLElement;
          const headerElement = this.header?.nativeElement;

          if (roundElement && headerElement) {
            const headerHeight = headerElement.offsetHeight;
            const elementTopPosition = roundElement.getBoundingClientRect().top + window.scrollY;
            const scrollTopPosition = elementTopPosition - headerHeight - 15; // 15px top padding
            window.scrollTo({ top: scrollTopPosition, behavior: 'smooth' });
          }
        });
      });
    });
  }

  private updateLogWithRestTime(actualRestTime: number): void {
    if (!this.lastLoggedSetForRestUpdate) return;

    const log = this.currentWorkoutLog();
    const exerciseLog = log.exercises?.find(e => e.sets.some(s => s.id === this.lastLoggedSetForRestUpdate!.id));
    if (exerciseLog) {
      const setLog = exerciseLog.sets.find(s => s.id === this.lastLoggedSetForRestUpdate!.id);
      if (setLog) {
        setLog.restLogged = restToExact(actualRestTime);
        this.currentWorkoutLog.set({ ...log });
        this.savePausedSessionState();
      }
    }
    // Clear the reference after updating
    this.lastLoggedSetForRestUpdate = null;
  }

  handleRestTimerFinished(): void {
    this.playEndSound();
    this.isRestTimerVisible.set(false);

    if (this.isManualRestActive && this.restTimerMode() === 'timer') {
      this.isManualRestActive = false;
      return;
    }

    // Standard post-set logic
    this.updateLogWithRestTime(this.restDuration());
  }

  handleRestTimerSkipped(timeSkipped: number): void {
    this.isRestTimerVisible.set(false);

    if (this.isManualRestActive && this.restTimerMode() === 'timer') {
      this.isManualRestActive = false;
      return;
    }

    // Standard post-set logic
    const actualRest = Math.ceil(this.restDuration() - timeSkipped);
    this.updateLogWithRestTime(actualRest);
    this.playerSubState.set(PlayerSubState.PerformingSet);
    this.audioService.playSound(AUDIO_TYPES.end);
  }

  private async peekNextStepInfo(completedExId: string, completedSetId: string): Promise<{ text: string | null; details: ExerciseTargetSetParams | null; exercise: WorkoutExercise | null; historicalSet: LoggedSet | null }> {
    const routine = this.routine();
    if (!routine) return { text: null, details: null, exercise: null, historicalSet: null };

    const currentExercise = routine.exercises.find(ex => ex.id === completedExId);
    let nextExercise: WorkoutExercise | undefined;
    let nextSetIndex: number | undefined;
    if (!currentExercise) return { text: null, details: null, exercise: null, historicalSet: null };
    const completedSetIndex = currentExercise.sets?.findIndex(set => set.id === completedSetId);

    // Logic to determine the next exercise and set index (remains the same)
    if (currentExercise && (completedSetIndex !== undefined) && (completedSetIndex + 1) < currentExercise.sets.length) {
      nextExercise = currentExercise;
      nextSetIndex = completedSetIndex + 1;
    } else if (completedSetIndex + 1 < routine.exercises.length) {
      nextExercise = routine.exercises[completedSetIndex + 1];
      nextSetIndex = 0;
    }

    if (nextExercise && nextSetIndex !== undefined) {
      const plannedNextSet = nextExercise.sets[nextSetIndex];
      try {
        const lastPerformance = await firstValueFrom(this.trackingService.getLastPerformanceForExercise(nextExercise.exerciseId));
        const historicalSet = this.trackingService.findPreviousSetPerformance(lastPerformance, plannedNextSet, nextSetIndex);

        // Return the ORIGINAL 'plannedNextSet' object in the 'details' property.
        // This ensures that `indexOf` will work correctly in the calling function.
        return { text: '', details: plannedNextSet, exercise: nextExercise, historicalSet: historicalSet };

      } catch (error) {
        console.error("Could not fetch last performance for next set:", error);
        // Also return the original object here on error.
        return { text: `${nextExercise.exerciseName} - Set ${nextSetIndex + 1}`, details: plannedNextSet, exercise: nextExercise, historicalSet: null };
      }
    }

    // Return for when the workout is complete
    return { text: "Workout Complete!", details: null, exercise: null, historicalSet: null };
  }

  // --- Pause, Resume, and State Management ---

  async pauseSession(): Promise<void> {
    if (this.sessionState() !== SessionState.Playing) return;
    this.sessionTimerElapsedSecondsBeforePause += Math.floor((Date.now() - this.workoutStartTime) / 1000);
    this.timerSub?.unsubscribe();
    this.sessionState.set(SessionState.Paused);
    this.savePausedSessionState();
    this.toastService.info(this.translate.instant('compactPlayer.toasts.workoutPaused'), 3000);
  }

  async resumeSession(): Promise<void> {
    if (this.sessionState() !== SessionState.Paused) return;
    this.workoutStartTime = Date.now();
    this.sessionState.set(SessionState.Playing);
    this.startSessionTimer();
    this.toastService.info(this.translate.instant('compactPlayer.toasts.workoutResumed'), 3000);
  }

  private savePausedSessionState(): void {
    if (!this.routine() || !this.routine()?.blocks || this.routine()?.blocks?.length === 0) return;
    if (this.sessionState() === SessionState.End || !this.routine()) return;

    let currentTotalSessionElapsed = this.sessionTimerElapsedSecondsBeforePause;
    if (this.sessionState() === SessionState.Playing) {
      currentTotalSessionElapsed += Math.floor((Date.now() - this.workoutStartTime) / 1000);
    }

    let dateToSaveInState: string;
    const loggedExercise: LoggedWorkoutExercise[] = (this.currentWorkoutLog() && this.currentWorkoutLog() && this.currentWorkoutLog().exercises) || [];
    const firstLoggedSetTime = loggedExercise && loggedExercise.length > 0 ? loggedExercise[0]?.sets[0]?.timestamp : format(new Date(), 'yyyy-MM-dd');
    const baseTimeForDate = firstLoggedSetTime ? new Date(firstLoggedSetTime) : (this.workoutStartTime > 0 ? new Date(this.workoutStartTime - (this.sessionTimerElapsedSecondsBeforePause * 1000)) : new Date());
    dateToSaveInState = format(baseTimeForDate, 'yyyy-MM-dd');

    const stringifiedRoutine = JSON.parse(JSON.stringify(this.routine()));
    const stateToSave: PausedWorkoutState = {
      version: this.workoutService.getPausedVersion(),
      routineId: this.routineId,
      programId: this.programId,
      programName: this.program()?.name,
      scheduledDayId: this.scheduledDay(),
      sessionRoutine: stringifiedRoutine, // Includes sessionStatus
      originalWorkoutExercises: this.originalRoutineSnapshot() ? JSON.parse(JSON.stringify(this.originalRoutineSnapshot())) : stringifiedRoutine,
      currentExerciseId: this.expandedExerciseId() || '',
      currentSetId: '',
      currentWorkoutLogExercises: JSON.parse(JSON.stringify(this.currentWorkoutLog() ? this.currentWorkoutLog().exercises : [])),
      workoutStartTimeOriginal: this.workoutStartTime,
      sessionTimerElapsedSecondsBeforePause: currentTotalSessionElapsed,
      currentBlockRound: -1,
      totalBlockRounds: -1,
      isResting: this.isRestTimerVisible(), // Full screen timer state
      isRestTimerVisibleOnPause: this.playerSubState() === PlayerSubState.Resting, // General resting sub-state
      restTimerRemainingSecondsOnPause: this.restDuration(), // Should be remaining time from timer component
      restTimerInitialDurationOnPause: 0,
      restTimerMainTextOnPause: this.restTimerMainText(),
      restTimerNextUpTextOnPause: this.restTimerNextUpText(),
      workoutDate: dateToSaveInState,
      performanceInputValues: this.performanceInputValues(),
    };

    this.workoutService.savePausedWorkout(stateToSave);
  }

  private async loadStateFromPausedSession(state: PausedWorkoutState): Promise<void> {
    this.routineId = state.routineId;
    this.programId = state.programId ? state.programId : null;
    this.scheduledDay.set(state.scheduledDayId ?? undefined);
    this.routine.set(state.sessionRoutine);

    this._prefillPerformanceInputs();
    this.sessionTimerElapsedSecondsBeforePause = state.sessionTimerElapsedSecondsBeforePause;
    const loggedExercises = state.currentWorkoutLogExercises;

    const absoluteStartTime = state.workoutStartTimeOriginal || Date.now();


    if (loggedExercises) {
      // Restore the log using the absolute start time.
      this.currentWorkoutLog.set({
        exercises: loggedExercises,
        notes: state.sessionRoutine.notes || '',
        startTime: absoluteStartTime, // Use the original start time for the log.
        routineId: this.routineId ?? undefined,
        programId: this.programId ?? undefined,
        scheduledDayId: this.scheduledDay() ?? undefined,
        routineName: state.sessionRoutine.name,
        date: state.workoutDate || format(new Date(absoluteStartTime), 'yyyy-MM-dd')
      });
      this.alignRestStartTimestampsFromLog();
    }

    if (state.performanceInputValues) {
      this.performanceInputValues.set(state.performanceInputValues);
    }

    // Now, reset the component's timer reference point to NOW for the new "playing" segment.
    this.workoutStartTime = Date.now();

    this.expandedExerciseId.set(state.currentExerciseId);

    // Set the initial timer display based on the accumulated pause time.
    const totalElapsedSeconds = this.sessionTimerElapsedSecondsBeforePause;
    const mins = String(Math.floor(totalElapsedSeconds / 60)).padStart(2, '0');
    const secs = String(totalElapsedSeconds % 60).padStart(2, '0');
    this.sessionTimerDisplay.set(`${mins}:${secs}`);

    // Start the session.
    this.sessionState.set(SessionState.Playing);
    this.startSessionTimer();
    // this.toastService.success('Paused session resumed', 3000);
  }

  private async checkForPausedSession(): Promise<boolean> {
    const pausedState = this.storageService.getItem<PausedWorkoutState>(this.PAUSED_WORKOUT_KEY);
    const routeRoutineId = this.route.snapshot.paramMap.get('routineId');

    if (pausedState) {
      this.programId = pausedState.programId || null;
      if (this.programId) {
        this.program.set(await firstValueFrom(this.trainingProgramService.getProgramById(this.programId)));
      }
      if (pausedState.version === this.PAUSED_STATE_VERSION && pausedState.routineId === routeRoutineId) {
        await this.loadStateFromPausedSession(pausedState);
        return true;
      } else {
        const confirmation = await this.alertService.showConfirmationDialog(
          this.translate.instant('compactPlayer.alerts.pausedWorkoutTitle'),
          this.translate.instant('compactPlayer.alerts.pausedWorkoutMessage'),
          [{ text: this.translate.instant('compactPlayer.alerts.resume'), role: "confirm", data: true, icon: 'play', cssClass: 'bg-green-600 hover:bg-green-700' },
          { text: this.translate.instant('compactPlayer.alerts.discard'), role: "cancel", data: false, icon: 'trash', cssClass: "bg-red-600 hover:bg-red-800" }]
        );

        if (confirmation?.data) {
          await this.loadStateFromPausedSession(pausedState);
          return true;
        } else {
          this.workoutService.removePausedWorkout();
          // this.toastService.info(this.translate.instant('compactPlayer.toasts.pausedDiscarded'), 3000);
          return false;
        }
      }
    }
    return false;
  }

  goBack(): void {
    // The exercises array might not exist on the partial log initially.
    // Check for its existence and then check its length to satisfy TypeScript's strict checks.
    this.clearRestTimers();
    if (this.currentWorkoutLog().exercises && this.currentWorkoutLog().exercises!.length > 0 && this.sessionState() === SessionState.Playing) {
      this.savePausedSessionState();
      this.router.navigate(['/home']);
    } else {
      this.router.navigate(['/home']);
    }
  }

  async addToSupersetModal(exerciseId: string): Promise<void> {
    const routine = this.routine();
    if (!routine) return;
    const loggedExercisesToExclude = this.currentWorkoutLog().exercises || [];

    const updatedRoutine = await this.workoutService.addToSupersetByStrings(
      routine,
      exerciseId,
      loggedExercisesToExclude,
      this.alertService,
      this.toastService
    );

    if (updatedRoutine) {
      this.routine.set(updatedRoutine);
      this.savePausedSessionState();
    }
  }

  async openCreateSupersetModal(exerciseId: string): Promise<void> {
    const routine = this.routine();
    if (!routine) return;
    const loggedExercisesToExclude = this.currentWorkoutLog().exercises || [];

    const result = await this.workoutService.createSupersetByStrings(
      routine,
      exerciseId,
      loggedExercisesToExclude,
    );

    // If the function returned updated data, apply it to the component's state
    if (result) {
      this.routine.set(result.updatedRoutine);

      // Update the log signal
      this.currentWorkoutLog.update(log => {
        log.exercises = result.updatedLoggedExercises;
        return { ...log };
      });

      this.savePausedSessionState(); // Persist the changes
      this._prefillPerformanceInputs();
    }
  }



  async completeRoundOrSet(exercise: WorkoutExercise, setId: string, event: Event) {
    event.stopPropagation();

    const isInGroup = this.isExerciseInGroupBlock(exercise.id);

    if (isInGroup) {
      // Get all exercises in this group
      const groupExercises = this.getExercisesInSameBlock(exercise.id);

      // Log all exercises in the group at the same set index
      const setIndex = exercise.sets.findIndex(s => s.id === setId);

      groupExercises.forEach(groupEx => {
        if (groupEx.sets[setIndex]) {
          this.toggleSetCompletion(groupEx, groupEx.sets[setIndex], groupEx.id, groupEx.sets[setIndex].id, false);
        }
      });
    } else {
      // Standard exercise: just toggle this set
      const set = exercise.sets.find(s => s.id === setId);
      if (set) {
        this.toggleSetCompletion(exercise, set, exercise.id, setId);
      }
    }

    await this.startRestPeriod(exercise.id, setId, this.getSetRestDuration(exercise.id, setId));
  }

  /**
   * HELPER: Finds the WorkoutGroup (block) that contains this exercise
   * This gives us access to the authoritative restBetweenRounds configuration
   */
  private getWorkoutGroupForExercise(exerciseId: string): WorkoutGroup | null {
    const routine = this.routine();
    if (!routine) return null;

    const block = this.workoutService.findBlockContainingExercise(routine, exerciseId);
    if (block?.type === 'group') {
      return (block.data as any) as WorkoutGroup;
    }
    return null;
  }


  areAllPropertiesFalsy(obj: any) {
    return Object.values(obj).every(value => !value);
  }

  isSuperSet(exerciseId: string): boolean {
    return this.isExerciseInGroupBlock(exerciseId);
  }

  protected isEmom(exerciseId: string): boolean {
    const blockType = this.getBlockType(exerciseId);
    return blockType === 'emom';
  }

  isSupersetStart(exerciseId: string): boolean {
    return this.isExerciseInGroupBlock(exerciseId) && this.getPositionInBlock(exerciseId) === 0;
  }

  isSupersetMiddle(exerciseId: string): boolean {
    if (!this.isExerciseInGroupBlock(exerciseId)) return false;
    const pos = this.getPositionInBlock(exerciseId);
    const size = this.getBlockSize(exerciseId);
    return pos > 0 && pos < size - 1;
  }
  // Return the total number of exercises in the superset group
  getSupersetSize(exerciseId: string): number {
    return this.getBlockSize(exerciseId);
  }

  isSupersetEnd(exerciseId: string): boolean {
    if (!this.isExerciseInGroupBlock(exerciseId)) return false;
    const pos = this.getPositionInBlock(exerciseId);
    const size = this.getBlockSize(exerciseId);
    return pos === size - 1;
  }

  isEndOfLastSupersetExercise(exerciseId: string, setId: string): boolean {
    const isLast = this.isSupersetEnd(exerciseId);
    if (!isLast) return false;

    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return false;

    const setIndex = exercise.sets.findIndex(s => s.id === setId);
    return setIndex === exercise.sets.length - 1;
  }

  /**
   * Returns the index of an exercise in the routine (flat array) given its exerciseId and setId,
   * using block-aware logic (handles both flat and block-based routines).
   * If not found, returns -1.
   */
  getExerciseIndexByIdFromBlocks(exerciseId: string, setId: string): number {
    const routine = this.routine();
    if (!routine) return -1;
    // Use the block-aware method to get all exercises in display order
    const allExercises = this.workoutService.getExercisesFlat(routine);
    return allExercises.findIndex(ex => ex.id === exerciseId && ex.sets.some(s => s.id === setId));
  }

  /**
 * Returns a display-friendly exercise index like "1", "1A", "1A/1B/1C", etc.
 * Uses block-first architecture to determine grouping.
 * 
 * @param exerciseId The ID of the exercise
 * @param expanded Whether to show full group (1A/1B/1C) or just this exercise (1A)
 * @returns Formatted display string
 */
  getExerciseDisplayIndex(exerciseId: string, expanded: boolean = false): string {
    const routine = this.routine();
    if (!routine?.exercises) return '';

    const currentEx = routine.exercises.find(ex => ex.id === exerciseId);
    if (!currentEx) return '';

    const currentBlock = this.getBlockForExercise(exerciseId);
    if (!currentBlock) return '';

    // Build a map of all blocks (for numbering)
    let blockNumber = 0;
    let currentBlockNumber = 0;
    let positionInCurrentBlock = 0;

    for (let i = 0; i < routine.exercises.length; i++) {
      const ex = routine.exercises[i];
      const exBlock = this.getBlockForExercise(ex.id);

      // Only increment block number when we see the first exercise of a new block
      if (!exBlock) continue;

      if (exBlock.type === 'single' || this.getPositionInBlock(ex.id) === 0) {
        blockNumber++;
        if (ex.id === exerciseId) {
          currentBlockNumber = blockNumber;
        }
      }

      // Track position within current block
      if (exBlock === currentBlock) {
        if (ex.id === exerciseId) {
          positionInCurrentBlock = this.getPositionInBlock(exerciseId);
        }
      }
    }

    // Determine display format
    if (currentBlock.type === 'single') {
      return `${currentBlockNumber}`;
    } else {
      // It's a group (superset/circuit/EMOM)
      if (expanded) {
        // Show only this exercise's letter (1A, 1B, etc.)
        return `${currentBlockNumber}${String.fromCharCode(65 + positionInCurrentBlock)}`;
      } else {
        // Show all exercises in group (1A/1B/1C)
        const allInBlock = currentBlock.data.exercises;
        return allInBlock
          .map((_, idx) => `${currentBlockNumber}${String.fromCharCode(65 + idx)}`)
          .join('/');
      }
    }
  }

  /**
   * Helper method to find the index of the first set in an exercise that has not been logged yet.
   * @param exerciseId: string The id of the exercise.
   * @returns The index of the first incomplete set, or -1 if all are complete.
   */
  protected findFirstIncompleteSetIndex(exerciseId: string): number {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) {
      return -1; // Should not happen in normal flow
    }
    // Find the index of the first set where isSetCompleted returns false
    return exercise.sets.findIndex((set, setIdx) => !this.isSetCompleted(exerciseId, set.id));
  }

  findCurrentExerciseIndex(exerciseId: string): number | undefined {
    return this.routine()?.exercises.findIndex(ex => ex.id === exerciseId);
  }

  findCurrentSetIndex(setId: string): number | undefined {
    const routine = this.routine();
    if (!routine) return undefined;
    for (let exIndex = 0; exIndex < routine.exercises.length; exIndex++) {
      const exercise = routine.exercises[exIndex];
      const setIndex = exercise.sets.findIndex(set => set.id === setId);
      if (setIndex !== -1) {
        return setIndex;
      }
    }
    return undefined;
  }
  /**
   * Determines the dynamic CSS classes for a set card based on its state.
   * Gives a special "focused" style to the first incomplete set when it's expanded.
   * @param exerciseId: string The id of the exercise.
   * @param setId The id of the set.
   * @param set The set data object.
   * @returns An object compatible with [ngClass].
   */
  public getSetClasses(exerciseId: string, setId: string, set: ExerciseTargetSetParams): any {
    const isCompleted = this.isSetCompleted(exerciseId, setId);
    const isExpanded = this.isSetExpanded(exerciseId, setId);
    const firstIncompleteIndex = this.findFirstIncompleteSetIndex(exerciseId);

    const setIndex = this.findCurrentExerciseIndex(exerciseId);
    const isNextUp = setIndex !== undefined && !isCompleted && setIndex === firstIncompleteIndex && !isExpanded;
    // A set is "focused" if it's the first incomplete one AND the user has expanded it.
    const isFocused = isExpanded && setIndex === firstIncompleteIndex;

    // Define classes based on priority: focused > completed > warmup > default
    if (isFocused) {
      return {
        // 'rounded-xl shadow-md transition-all duration-300': true,
        'rounded-xl shadow-md': true,
        'relative ring-2 ring-yellow-400 dark:ring-yellow-500 z-10': true, // Focus style
        'bg-white dark:bg-gray-800': set.type !== 'warmup', // Default background when focused
        'relative ring-2 ring-blue-400 dark:ring-blue-500 z-10 bg-blue-100 dark:bg-blue-700/80': set.type === 'warmup'
      };
    }

    // "Next up" ring (not expanded)
    if (isNextUp) {
      return {
        // 'rounded-xl shadow-sm transition-all duration-300 pb-2': true,
        'rounded-xl shadow-sm': true,
        // 'rounded-xl shadow-sm pb-2': true,
        'relative ring-2 ring-yellow-400 dark:ring-yellow-500 z-10': true, // Next up ring
        'bg-white dark:bg-gray-800': set.type !== 'warmup',
        'border-2 border-blue-400 dark:border-blue-500 bg-blue-100 dark:bg-blue-700/80': set.type === 'warmup',
      };
    }

    if (isCompleted) {
      return {
        // 'rounded-xl shadow-sm transition-all duration-300 pb-2': true,
        'rounded-xl shadow-sm': true,
        // 'rounded-xl shadow-sm pb-2': true,
        'bg-green-300 dark:bg-green-700 border border-green-300 dark:border-green-800': true, // Subtle completed style
      };
    }

    // Default style for a standard, non-focused, non-completed set
    return {
      // 'rounded-xl shadow-sm transition-all duration-300 pb-2': true,
      'rounded-xl shadow-sm transition-all duration-300': true,
      'bg-white dark:bg-gray-800': set.type !== 'warmup',
      'border-2 border-blue-400 dark:border-blue-500 bg-blue-100 dark:bg-blue-700/80': set.type === 'warmup', // Subtle warmup style
    };
  }

  getExerciseClasses(exercise: WorkoutExercise, exerciseId: string): any {
    const isInGroupBlock = this.isExerciseInGroupBlock(exerciseId);
    const isEmomSet = this.isEmom(exerciseId);
    const isStandardSet = !isInGroupBlock && !isEmomSet;
    const positionInBlock = this.getPositionInBlock(exerciseId);
    const isExpanded = this.expandedExerciseId() === exerciseId;

    // --- Base classes that apply to almost all states ---
    const classes: any = {
      // Side borders always apply to group block items
      'border-l-2 border-r-2 rounded-md': isInGroupBlock || isEmomSet,
      'border-primary': isInGroupBlock && !isEmomSet,
      'border-teal-400': isEmomSet,
      // Standalone exercises always get these classes
      'mb-4 rounded-md': isStandardSet,
    };

    // --- State-Specific Logic ---
    if (isStandardSet && isExpanded) {
      classes['mb-8'] = true;
    }
    if ((isInGroupBlock || isEmomSet) && isExpanded) {
      // STATE 1: THE EXERCISE IS EXPANDED
      // It becomes a self-contained, highlighted block.
      classes['rounded-md'] = true;       // Round all corners
      classes['border-t-2'] = true;       // Ensure it has a top border
      classes['border-b-2'] = true;       // Ensure it has a bottom border
      classes['mb-8'] = true;             // Add margin to visually detach it from the item below

    } else {
      // STATE 2: THE EXERCISE IS COLLAPSED (OR STANDALONE)
      // Apply the normal start, middle, and end classes for visual grouping.
      classes['border-t-2 rounded-t-md'] = isInGroupBlock && positionInBlock === 0;
      classes['border-b-0 rounded-none'] = isInGroupBlock && positionInBlock > 0 && positionInBlock < (this.getBlockSize(exerciseId) - 1);
      classes['border-b-2'] = isInGroupBlock;
      classes['rounded-b-md mb-4'] = true;
    }

    // --- Background Color Logic (applied last, doesn't affect layout) ---
    if (isInGroupBlock && positionInBlock % 2 !== 0) {
      classes['bg-gray-200/80 dark:bg-gray-800'] = true; // Striped background
    } else {
      classes['bg-white dark:bg-gray-700'] = true; // Default background
    }

    return classes;
  }
  private getRoundInfo(ex: WorkoutExercise): { round: number, totalRounds: number } {
    //  Total rounds for a superset is its number of sets. For standard, it's 1.
    const totalRounds = this.isExerciseInGroupBlock(ex.id) ? ex.sets.length : 1;

    // The current round is based on how many sets have been logged.
    const loggedSetsCount = this.currentWorkoutLog().exercises?.find(logEx => logEx.id === ex.id)?.sets.length ?? 0;
    const currentRound = loggedSetsCount + 1;

    return { round: currentRound, totalRounds };
  }



  private comparePerformedToOriginal(performed: LoggedWorkoutExercise[], original: WorkoutExercise[]): { majorDifference: boolean; details: string[] } {
    const details: string[] = [];
    let majorDifference = false;
    const originalIdSet = new Set(original.map(ex => ex.id));
    const performedInOriginal: LoggedWorkoutExercise[] = [];
    const addedCustomExercises: LoggedWorkoutExercise[] = [];

    for (const pEx of performed) {
      if (originalIdSet.has(pEx.id)) {
        performedInOriginal.push(pEx);
      } else {
        addedCustomExercises.push(pEx);
      }
    }

    if (addedCustomExercises.length > 0) {
      majorDifference = true;
      addedCustomExercises.forEach(ex => details.push(`Exercise added: ${ex.exerciseName}`));
    }

    for (const originalEx of original) {
      const performedEx = performed.find(p => p.id === originalEx.id);
      if (!performedEx) {
        majorDifference = true;
        details.push(`Exercise skipped: "${originalEx.exerciseName || originalEx.exerciseId}"`);
        continue;
      }

      if (performedEx.sets.length !== originalEx.sets.length) {
        majorDifference = true;
        details.push(`Set count for "${performedEx.exerciseName}" changed (Planned: ${originalEx.sets.length}, Performed: ${performedEx.sets.length})`);
      }
    }
    return { majorDifference, details };
  }

  /**
* Converts logged exercises into a block structure (WorkoutBlock[])
* This organizes exercises into hierarchical blocks by checking the current routine's blocks
* to determine which exercises are grouped together.
* 
* @param loggedExercises Array of LoggedWorkoutExercise from the session
* @returns Array of WorkoutBlock representing the hierarchical structure
*/
  private convertLoggedToWorkoutBlocks(loggedExercises: LoggedWorkoutExercise[]): WorkoutBlock[] {
    const routine = this.routine();
    if (!routine?.blocks) return [];

    const blocks: WorkoutBlock[] = [];
    const processedExerciseIds = new Set<string>();

    for (const block of routine.blocks) {
      if (block.type === 'single') {
        // This is a standalone exercise block
        const exerciseId = block.data.id;
        const loggedEx = loggedExercises.find(le => le.id === exerciseId);

        if (loggedEx) {
          // Convert the logged exercise to WorkoutExercise format
          const singleExercise: WorkoutExercise = {
            id: loggedEx.id,
            exerciseId: loggedEx.exerciseId,
            exerciseName: loggedEx.exerciseName,
            notes: loggedEx.notes,
            sets: loggedEx.sets.map(loggedSet => ({
              id: loggedSet.id,
              targetReps: loggedSet.repsLogged,
              targetWeight: loggedSet.weightLogged,
              targetDuration: loggedSet.durationLogged,
              targetDistance: loggedSet.distanceLogged,
              targetRest: loggedSet.restLogged,
              targetTempo: loggedSet.tempoLogged,
              notes: loggedSet.notes,
              type: loggedSet.type as any,
              fieldOrder: loggedSet.fieldOrder
            }))
          };

          const singleBlock: WorkoutBlock = {
            type: 'single',
            data: singleExercise
          };

          blocks.push(singleBlock);
          processedExerciseIds.add(exerciseId);
        }
      } else if (block.type === 'group') {
        // This is a group block (superset/circuit/EMOM/amrap_round)
        const groupExerciseIds = block.data.exercises.map(ex => ex.id);
        const loggedGroupExercises = loggedExercises.filter(le => groupExerciseIds.includes(le.id));

        if (loggedGroupExercises.length > 0) {
          // Convert each exercise in the group to WorkoutExercise format, maintaining order
          const blockExercises: WorkoutExercise[] = groupExerciseIds
            .map(exId => loggedGroupExercises.find(le => le.id === exId))
            .filter((ex): ex is LoggedWorkoutExercise => ex !== undefined)
            .map(loggedEx => ({
              id: loggedEx.id,
              exerciseId: loggedEx.exerciseId,
              exerciseName: loggedEx.exerciseName,
              notes: loggedEx.notes,
              sets: loggedEx.sets.map(loggedSet => ({
                id: loggedSet.id,
                targetReps: loggedSet.repsLogged,
                targetWeight: loggedSet.weightLogged,
                targetDuration: loggedSet.durationLogged,
                targetDistance: loggedSet.distanceLogged,
                targetRest: loggedSet.restLogged,
                targetTempo: loggedSet.tempoLogged,
                notes: loggedSet.notes,
                type: loggedSet.type as any,
                fieldOrder: loggedSet.fieldOrder
              }))
            }));

          // Create group block with the same configuration as the original
          const groupBlock: WorkoutBlock = {
            type: 'group',
            data: {
              id: block.data.id,
              type: block.data.type,
              exercises: blockExercises,
              config: {
                rounds: block.data.config?.rounds,
                restBetweenRounds: block.data.config?.restBetweenRounds,
                emomInterval: block.data.config?.emomInterval,
                amrapTimeCap: block.data.config?.amrapTimeCap
              }
            } as WorkoutGroup
          };

          blocks.push(groupBlock);
          groupExerciseIds.forEach(id => processedExerciseIds.add(id));
        }
      }
    }

    // Handle any logged exercises that weren't in the original routine blocks
    // (e.g., exercises added during the session)
    const addedExercises = loggedExercises.filter(le => !processedExerciseIds.has(le.id));
    for (const loggedEx of addedExercises) {
      const singleExercise: WorkoutExercise = {
        id: loggedEx.id,
        exerciseId: loggedEx.exerciseId,
        exerciseName: loggedEx.exerciseName,
        notes: loggedEx.notes,
        sets: loggedEx.sets.map(loggedSet => ({
          id: loggedSet.id,
          targetReps: loggedSet.repsLogged,
          targetWeight: loggedSet.weightLogged,
          targetDuration: loggedSet.durationLogged,
          targetDistance: loggedSet.distanceLogged,
          targetRest: loggedSet.restLogged,
          targetTempo: loggedSet.tempoLogged,
          notes: loggedSet.notes,
          type: loggedSet.type as any,
          fieldOrder: loggedSet.fieldOrder
        }))
      };

      blocks.push({
        type: 'single',
        data: singleExercise
      });
    }

    return blocks;
  }

  private convertLoggedToWorkoutExercises(loggedExercises: LoggedWorkoutExercise[]): WorkoutExercise[] {
    const currentSessionRoutine = this.routine();
    return loggedExercises.map(loggedEx => {
      const sessionExercise = currentSessionRoutine?.exercises.find(re => re.exerciseId === loggedEx.exerciseId);
      return {
        id: uuidv4(),
        exerciseId: loggedEx.exerciseId,
        exerciseName: loggedEx.exerciseName,
        notes: sessionExercise?.notes,
        sets: loggedEx.sets.map(loggedSet => {
          const originalPlannedSet = sessionExercise?.sets.find(s => s.id === loggedSet.plannedSetId);
          return {
            id: uuidv4(),
            targetReps: loggedSet.repsLogged,
            targetWeight: loggedSet.weightLogged,
            targetDuration: loggedSet.durationLogged,
            targetRest: loggedSet.restLogged,
            targetTempo: loggedSet.tempoLogged,
            notes: loggedSet.notes,
            type: loggedSet.type as any,
            fieldOrder: loggedSet.fieldOrder
          };
        })
      };
    });
  }


  /**
     * --- OPTIMIZED ---
     * Generates a display string for a set's planned target.
     * It now reads from the pre-calculated `suggestedRoutine` signal, making it
     * extremely fast and safe to call from the template.
     */
  public getSetTargetDisplay(exerciseId: string, setId: string, field: METRIC): string {
    const routineWithSuggestions = this.suggestedRoutine();
    if (!routineWithSuggestions) return '';

    let setForDisplay;

    // Special handling: For REST metric in group blocks (not EMOM), use the last exercise
    if (field === METRIC.rest && this.isExerciseInGroupBlock(exerciseId) && !this.isEmom(exerciseId)) {
      const exercisesInGroup = this.getExercisesInSameBlock(exerciseId);
      const lastExercise = exercisesInGroup[exercisesInGroup.length - 1];
      setForDisplay = lastExercise?.sets.find(set => set.id === setId);
    } else {
      const exercise = this.getWorkoutExerciseById(routineWithSuggestions, exerciseId);
      setForDisplay = exercise?.sets.find(set => set.id === setId);
    }

    if (!setForDisplay) return '';
    return this.workoutUtilsService.getSetTargetDisplay(setForDisplay, field);
  }

  /**
   * Unlocks the screen orientation, allowing it to change freely again.
   * This should be called when the user navigates away from the workout player.
   */
  private unlockScreenOrientation(): void {
    if (isPlatformBrowser(this.platformId) && screen.orientation) {
      try {
        screen.orientation.unlock();
        console.log('Screen orientation unlocked.');
      } catch (error) {
        console.error('Failed to unlock screen orientation:', error);
      }
    }
  }

  /**
  * Returns all exercises in the same block (superset/circuit/EMOM group).
  * Replaces the old supersetId-based lookup with block-first logic.
  * 
  * @param exerciseId The ID of any exercise in the group
  * @returns All exercises in the same block, or empty array if standalone
  */
  getSupersetExercises(exerciseId: string): WorkoutExercise[] {
    const routine = this.routine();
    if (!routine?.exercises) return [];

    const block = this.getBlockForExercise(exerciseId);
    if (!block || block.type === 'single') return [];

    // Return all exercises in this group block
    return block.data.exercises;
  }

  getOriginalExId(exerciseId: string): string {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    return exercise ? exercise.id : '';
  }

  isRoundCompleted(exerciseId: string, roundId: string): boolean {
    if (!this.isExerciseInGroupBlock(exerciseId)) return false;

    const exercisesInGroup = this.getSupersetExercises(exerciseId);
    return exercisesInGroup.every(ex => {
      const originalExIndex = this.getOriginalExId(ex.id);
      return this.isSetCompleted(originalExIndex, roundId);
    });
  }

  getEmomState(exerciseId: string, roundId: string): { status: TimerSetState, remainingTime: number } {
    // 1. FIRST, check the source of truth: the workout log.
    // If the log shows this round is completed, ALWAYS return a 'completed' state.
    // This is a PURE READ operation.
    if (this.isRoundCompleted(exerciseId, roundId)) {
      return { status: TimerSetState.Completed, remainingTime: 0 };
    }

    // 2. If the round is not completed, THEN read the current timer state from the signal.
    // This handles the 'idle', 'running', and 'paused' states for active timers.
    const key = this.getSetKey(exerciseId, roundId);
    const allStates = this.emomState();
    const duration = this.getBlockEmomInterval(exerciseId);
    return allStates[key] || { status: TimerSetState.Idle, remainingTime: duration };
  }

  handleEmomAction(exerciseId: string, roundId: string): void {
    const key = this.getSetKey(exerciseId, roundId);
    const state = this.getEmomState(exerciseId, roundId);

    switch (state.status) {
      case TimerSetState.Idle:
      case TimerSetState.Paused:
        this.startEmomTimer(exerciseId, roundId, key);
        break;
      case TimerSetState.Running:
        this.pauseEmomTimer(key);
        break;
      case TimerSetState.Completed:
        // Do nothing if already completed
        break;
    }
  }

  private playCountdownSound(currentRemaining: number): void {
    if (
      this.appSettingsService.enableTimerCountdownSound() &&
      currentRemaining <= this.appSettingsService.countdownSoundSeconds()
      && currentRemaining !== this.lastBeepSecond
    ) {
      this.audioService.playSound(AUDIO_TYPES.countdown);
      this.lastBeepSecond = currentRemaining;
    }
  }

  private playEndSound(): void {
    if (
      this.appSettingsService.enableTimerCountdownSound()
    ) {
      this.audioService.playSound(AUDIO_TYPES.end);
      this.lastBeepSecond = null;
    }
  }

  private startEmomTimer(exerciseId: string, roundId: string, key: string): void {
    this.lastBeepSecond = null;
    const duration = this.getBlockEmomInterval(exerciseId);

    this.emomState.update(states => {
      if (!states[key]) {
        states[key] = { status: TimerSetState.Running, remainingTime: duration };
      } else {
        states[key].status = TimerSetState.Running;
      }
      return { ...states };
    });

    this.emomTimerSub?.unsubscribe();
    this.emomTimerSub = timer(0, 1000).subscribe(() => {
      const currentRemaining = this.emomState()[key]?.remainingTime;
      if (currentRemaining > 0) {
        this.playCountdownSound(currentRemaining);

        this.emomState.update(states => {
          states[key].remainingTime--;
          return { ...states };
        });
      } else {
        this.emomTimerSub?.unsubscribe();
        this.logEmomRoundAsCompleted(exerciseId, roundId, key);

        // --- AUTO-SCROLL LOGIC ---
        const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
        if (exercise) {
          const nextRoundIndex = (this.findCurrentSetIndex(roundId) ?? 0) + 1;
          const hasNextRound = nextRoundIndex < exercise.sets.length;

          if (hasNextRound) {
            // 1. Expand the next round and collapse the one we just finished
            this.expandedRounds.update(currentSet => {
              const newSet = new Set(currentSet);
              newSet.delete(this.getSetKey(exerciseId, roundId));
              newSet.add(this.getSetKey(exerciseId, exercise.sets[nextRoundIndex].id));
              return newSet;
            });

            // 2. Scroll to the new round
            this.scrollCurrentElementIntoView(exerciseId, exercise.sets[nextRoundIndex].id);
          } else {
            // No more rounds, start rest timer after EMOM
            this.startRestPeriod(exerciseId, roundId, this.getSetRestDuration(exerciseId, roundId));
          }
        }
      }
    });
  }

  private pauseEmomTimer(key: string): void {
    this.emomTimerSub?.unsubscribe();
    this.emomState.update(states => {
      if (states[key]) {
        states[key].status = TimerSetState.Paused;
      }
      return { ...states };
    });
  }

  private logEmomRoundAsCompleted(exerciseId: string, roundId: string, key: string): void {
    const firstExercise = this.getWorkoutExerciseById(this.routine()!, exerciseId);
    if (!firstExercise) return;
    const exercisesInGroup = this.getSupersetExercises(exerciseId);

    exercisesInGroup.forEach(ex => {
      const originalIndex = this.getOriginalExId(ex.id);
      const setForRound = ex.sets[Number(roundId)];
      if (setForRound && !this.isSetCompleted(originalIndex, roundId)) {
        // Log with target values
        this.toggleSetCompletion(ex, setForRound, originalIndex, roundId);
      }
    });

    this.emomState.update(states => {
      states[key] = { ...states[key], status: TimerSetState.Completed, remainingTime: 0 };
      return { ...states };
    });

    const roundIndex = this.findCurrentSetIndex(roundId) ?? 0;
    this.toastService.success(`EMOM Round ${roundIndex + 1} Complete!`);
  }

  getEmomButtonText(exerciseId: string, roundId: string): string {
    const state = this.getEmomState(exerciseId, roundId);
    const textMap = { idle: 'START ROUND', running: 'PAUSE', paused: 'RESUME', completed: 'COMPLETED' };
    return textMap[state.status];
  }

  getEmomButtonIcon(exerciseId: string, roundId: string): string {
    const state = this.getEmomState(exerciseId, roundId);
    const iconMap = { idle: 'play', running: 'pause', paused: 'play', completed: 'done' };
    return iconMap[state.status];
  }

  getEmomButtonClass(exerciseId: string, roundId: string): string {
    const state = this.getEmomState(exerciseId, roundId);
    const classMap = {
      idle: 'bg-teal-500 hover:bg-teal-600',
      running: 'bg-yellow-500 hover:bg-yellow-600',
      paused: 'bg-teal-500 hover:bg-teal-600 animate-pulse',
      completed: 'bg-green-600'
    };
    return classMap[state.status];
  }

  getSupersetDisplayName(supersetId: string): string {
    const routine = this.routine();
    const exercise = routine?.exercises.find(ex => ex.id === supersetId);
    if (!exercise) return 'Group';

    const blockType = this.getBlockType(exercise.id);
    if (blockType === 'emom') {
      const block = this.getBlockForExercise(exercise.id);
      const interval = block?.type === 'group' ? block.data.config?.emomInterval || 60 : 60;
      return `EMOM (${interval}s)`;
    }
    if (blockType === 'circuit') return 'Circuit';
    if (blockType === 'superset') return 'Superset';
    return 'Group';
  }

  /**
     * --- OPTIMIZED ---
     * Formats the display string for the "Next Up" section of the rest timer.
     * It also reads from the efficient `suggestedRoutine` signal.
     */
  private formatSetTargetForDisplay(set: ExerciseTargetSetParams, exercise: WorkoutExercise, exerciseId: string, setId: string): string {
    // Get the pre-calculated set from the suggestedRoutine signal
    const routine = this.suggestedRoutine();
    const exerciseForDisplay = this.getWorkoutExerciseById(routine, exerciseId);
    const setForDisplay = exerciseForDisplay?.sets.find(s => s.id === setId) || set;

    if (this.isCardio(exercise)) {
      const distance = setForDisplay.targetDistance ?? distanceToExact(0);
      const duration = setForDisplay.targetDuration ?? durationToExact(0);
      let parts: string[] = [];
      if (getDistanceValue(distance) > 0) parts.push(`${distance} ${this.unitsService.getDistanceUnitSuffix()}`);
      if (getDurationValue(duration) > 0) parts.push(this.formatSecondsToTime(getDurationValue(duration)));
      return parts.length > 0 ? `Target: ${parts.join(' for ')}` : 'No target set';
    } else {
      // Use the pre-calculated set to get the display values for reps and weight
      const repsDisplay = this.workoutUtilsService.getSetTargetDisplay(setForDisplay, METRIC.reps);
      const weightDisplay = this.workoutUtilsService.getSetWeightDisplay(setForDisplay, exercise);

      return repsDisplay ? `Target: ${weightDisplay} x ${repsDisplay} reps` : 'No target set';
    }
  }

  /** Checks if a specific round is currently expanded. */
  isRoundExpanded(exerciseId: string, roundId: string): boolean {
    const key = this.getSetKey(exerciseId, roundId);
    return this.expandedRounds().has(key);
  }

  /** Toggles the expanded/collapsed state of a specific round. */
  toggleRoundExpansion(exerciseId: string, roundId: string, event: Event): void {
    if (event) {
      const target = event.target as HTMLElement;
      if (target.closest('button') || ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName)) {
        return;
      }


      // Ignore clicks inside the #exerciseCard
      if (target.closest('#exerciseCard')) {
        return;
      }

    }
    event.stopPropagation(); // Prevent the main card from toggling
    const key = this.getSetKey(exerciseId, roundId);

    this.expandedRounds.update(currentSet => {
      const newSet = new Set(currentSet); // Create a new instance to ensure signal change detection
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        newSet.add(key);
      }
      return newSet;
    });
  }

  performanceInputValues = signal<{ [key: string]: Partial<ExerciseCurrentExecutionSetParams> }>({});

  /**
   * Determines the initial value for an input field.
   * 1. If the set is already logged, it shows the logged value.
   * 2. If the user has typed something for this set, it shows their input.
   * 3. If a range is defined (e.g., 8-12 reps), it shows the middle value.
   * 4. Otherwise, it shows the planned single target value as the default.
   */
  getInitialInputValue(exerciseId: string, setId: string, field: 'notes'): string {
    const routine = this.routine();
    if (!routine) return '';

    const key = this.getSetKey(exerciseId, setId);;
    const userInputs = this.performanceInputValues()[key] || {};
    const loggedSet = this.getLoggedSet(exerciseId, setId);

    // PRIORITY 1: Show already logged data if it exists. (COMPLETED SET)
    if (loggedSet) {
      switch (field) {
        case 'notes': return loggedSet.notes ?? '';
      }
    }

    // PRIORITY 2: Show what the user has typed for this specific field if it exists.
    if (userInputs) {
      if (userInputs.notes) {
        return userInputs.notes ?? '';
      }
    }
    return '';

  }

  updateSetData(exerciseId: string, setId: string, field: 'notes' | METRIC.tempo, event: Event): void {
    const value = (event.target as HTMLInputElement).value;
    const key = this.getSetKey(exerciseId, setId);;

    this.performanceInputValues.update(currentInputs => {
      const newInputs = { ...currentInputs };
      if (!newInputs[key]) {
        newInputs[key] = {};
      }
      if (field === 'notes') {
        newInputs[key].notes = value;
      } else if (field === METRIC.tempo) {
        newInputs[key].tempoLogged = value === '' ? undefined : value;
      }
      return newInputs;
    });
  }

  /**
  * On completion, this method now builds the log entry by combining three sources:
  * 1. The user's input (`performanceInputValues`).
  * 2. The routine's plan (as a fallback for performed values).
  * 3. The original snapshot (for target values).
  */
  toggleSetCompletion(exercise: WorkoutExercise, set: ExerciseTargetSetParams, exerciseId: string, setId: string, triggerAnimation: boolean = true): void {
    const log = this.currentWorkoutLog();
    if (!log.exercises) log.exercises = [];

    let exerciseLog = log.exercises.find(e => e.id === exercise.id);
    const wasCompleted = !!this.getLoggedSet(exerciseId, setId);
    const plannedSetId = this.getPlannedSetId(exercise, set);

    const key = this.getSetKey(exerciseId, setId);;

    if (triggerAnimation) {
      const key = this.getSetKey(exerciseId, setId);;
      this.toggledSetAnimation.set({ key, type: 'set', state: wasCompleted ? 'incompleted' : 'completed' });
    }

    if (wasCompleted) {
      this.audioService.playSound(AUDIO_TYPES.untoggle);
      // Un-logging logic is now updated to restore values to the input state
      if (exerciseLog) {
        const setIndexInLog = exerciseLog.sets.findIndex(s => s.plannedSetId === plannedSetId);
        if (setIndexInLog > -1) {
          const unloggedSet = exerciseLog.sets[setIndexInLog];
          // Restore the unlogged values back into the temporary input state
          this.performanceInputValues.update(inputs => {
            inputs[key] = {
              actualReps: set.targetReps,
              actualWeight: set.targetWeight,
              actualDuration: set.targetDuration,
              actualDistance: set.targetDistance,
              actualRest: set.targetRest,
              notes: unloggedSet.notes
            };
            return { ...inputs };
          });
          exerciseLog.sets.splice(setIndexInLog, 1);
        }
      }

      // --- Reset the compact rest timer for this set ---
      if (this.restStartTimestamps[this.getSetKey(exerciseId, setId)]) {
        delete this.restStartTimestamps[this.getSetKey(exerciseId, setId)];
      }
      if (this.compactRestInterval) {
        clearInterval(this.compactRestInterval);
        this.compactRestInterval = null;
        this.lastCompactRestBeepSecond = null;
      }

    } else {

      const userInputs = this.performanceInputValues()[key] || {};
      const exerciseObj = this.getWorkoutExerciseById(this.routine()!, exerciseId);
      if (!exerciseObj) return;
      const plannedSet = exerciseObj.sets.find(set => set.id === setId);
      if (!plannedSet) return;
      // Check if the planned set is a textual rep type (AMRAP, MAX, etc.)
      if (this.isTextReps(exerciseId, setId)) {
        // If it is, the user's *actual* logged value must be an exact number.
        // It cannot still be AMRAP/MAX when they try to complete the set.
        if (!userInputs.actualReps || userInputs.actualReps.type !== RepsTargetType.exact) {
          this.toastService.info(
            this.translate.instant('compactPlayer.toasts.enterNumericRepsError', {
              repType: repsTargetAsString(plannedSet.targetReps)
            }),
            4000, // Duration 0 makes it sticky until dismissed
            this.translate.instant('common.error')
          );
          // Vibrate to give haptic feedback for the error
          this.workoutService.vibrate();
          return; // Abort the completion
        }
      }

      // check if is text weight as well
      const isBodyweightTarget = plannedSet.targetWeight && plannedSet.targetWeight.type === WeightTargetType.bodyweight;
      if (this.isTextWeight(exerciseId, setId)) {
        // Allow 0 if the planned target was bodyweight
        if (!isBodyweightTarget) {
          this.toastService.info(
            this.translate.instant('compactPlayer.toasts.enterNumericWeightError', {
              weightType: this.workoutUtilsService.weightTargetAsString(plannedSet.targetWeight)
            }),
            6000,
            this.translate.instant('common.error')
          );
          this.workoutService.vibrate();
          return;
        }
        if (isBodyweightTarget && (!userInputs.actualWeight || getWeightValue(userInputs.actualWeight) === 0)) {
          userInputs.actualWeight = { type: WeightTargetType.bodyweight } as WeightTarget;
        }
      }
      if (plannedSet.targetWeight && !isBodyweightTarget && (!userInputs.actualWeight || getWeightValue(userInputs.actualWeight) === 0)) {
        this.toastService.info(
          this.translate.instant('compactPlayer.toasts.enterNumericWeightError', {
            weightType: this.workoutUtilsService.weightTargetAsString(plannedSet.targetWeight)
          }),
          6000,
          this.translate.instant('common.error')
        );
        this.workoutService.vibrate();
        return;
      }

      this.audioService.playSound(AUDIO_TYPES.correct);
      // Logging logic
      if (!exerciseLog) {
        exerciseLog = { id: exercise.id, exerciseId: exercise.exerciseId, exerciseName: exercise.exerciseName!, sets: [] };
        log.exercises.push(exerciseLog);
      }

      // Give priority to the set from the original routine, otherwise use the newly added exercise set
      const originalSet = this.getWorkoutExerciseById(this.originalRoutineSnapshot()!, exerciseId)?.sets.find(s => s.id === setId) || set;
      const targetSetValues: ExerciseTargetExecutionSetParams = mapExerciseTargetSetParamsToExerciseExecutedSetParams(set);

      const timerState = this.setTimerState()[key];
      // retrieve actual duration from timer if available considering target
      // Calculate actual duration performed if timerState and targetSetValues are available
      let actualDurationLogged: number | null = null;
      const userDefinedDuration = userInputs.actualDuration;

      // PRIORITY 1: If a timer was ACTIVELY running or paused when the set was completed.
      // This captures the elapsed time accurately.
      if (timerState && timerState.remainingTime) {
        if (userDefinedDuration !== undefined && userDefinedDuration !== null) {
          actualDurationLogged = getDurationValue(userDefinedDuration) - timerState.remainingTime;
        } else {
          actualDurationLogged = (getDurationValue(targetSetValues.targetDuration) ?? 0) - timerState.remainingTime;
        }
      } else {
        // PRIORITY 2: If no timer was active, check for a manual user input.
        if (userDefinedDuration !== undefined && userDefinedDuration !== null) {
          actualDurationLogged = getDurationValue(userDefinedDuration);
        }
      }

      const userDefinedRest = userInputs.actualRest;

      if (userDefinedRest !== undefined && userDefinedRest !== null) {
        set.targetRest = userDefinedRest;
      }


      if (!actualDurationLogged || actualDurationLogged <= 0) {
        actualDurationLogged = getDurationValue(userDefinedDuration) ?? targetSetValues.targetDuration ?? 0;
      }

      // check if it was a timed set with an active timer, and stop it
      if (timerState && (timerState.status === 'running' || timerState.status === 'paused')) {
        this.setTimerSub?.unsubscribe();
        this.setTimerState.update(states => {
          delete states[key];
          return { ...states };
        });
      }

      // Create the log entry by prioritizing user input, then falling back to the planned target
      const newLoggedSet: LoggedSet = {
        id: uuidv4(),
        exerciseName: exercise.exerciseName,
        plannedSetId: plannedSetId,
        exerciseId: exercise.exerciseId,
        type: set.type,
        fieldOrder: set.fieldOrder,
        repsLogged: userInputs.actualReps ?? set.targetReps ?? undefined,
        weightLogged: userInputs.actualWeight ?? set.targetWeight ?? undefined,
        durationLogged: userInputs.actualDuration ?? set.targetDuration ?? undefined,
        distanceLogged: userInputs.actualDistance ?? set.targetDistance ?? undefined,
        restLogged: userInputs.actualRest ?? set.targetRest ?? undefined,
        notes: userInputs.notes ?? set.notes,
        tempoLogged: userInputs.tempoLogged ?? set.targetTempo,
        timestamp: new Date().toISOString(),
        // Target values: Always come from the original, static snapshot
        targetRest: originalSet?.targetRest ?? targetSetValues?.targetRest ?? undefined,
        targetReps: originalSet?.targetReps ?? targetSetValues?.targetReps ?? undefined,
        targetWeight: originalSet?.targetWeight ?? targetSetValues?.targetWeight ?? undefined,
        targetDuration: originalSet?.targetDuration ?? targetSetValues?.targetDuration ?? undefined,
        targetDistance: originalSet?.targetDistance ?? targetSetValues?.targetDistance ?? undefined,
        workoutLogId: uuidv4(), // to differ from Simple set,
      };
      exerciseLog.sets.push(newLoggedSet);

      // // Clean up the temporary input state for this set after logging
      // this.performanceInputValues.update(inputs => {
      //   delete inputs[key];
      //   return { ...inputs };
      // });
    }

    // --- (The rest of the method for state updates, saving, and timers remains the same) ---
    this.currentWorkoutLog.set({
      ...log,
      exercises: log.exercises ? log.exercises.map(e =>
        e.id === exercise.id
          ? { ...e, sets: [...e.sets] }
          : e
      ) : []
    });

    this.savePausedSessionState();
    this.lastExerciseId.set(exerciseId);
    this.lastExerciseSetId.set(setId);

    this.lastExerciseIndex.set(exerciseIndex);
    this.lastSetIndex.set(setIndex);

    this.workoutService.vibrate();

    if (!wasCompleted) {
      // Get the set index for rest lookup
      const setIndex = exercise.sets.findIndex(s => s.id === setId);

      // Use the universal rest helper for any block type
      const restToUse = this.getRestForSuperset(exerciseId, setIndex);
      const restValue = restToUse ? getRestValue(restToUse) : 0;

      // For supersets: only start rest on the LAST exercise of the group
      // For standard exercises: always start rest
      // const shouldStartRest = restValue > 0 && this.isEndOfLastSupersetExercise(exerciseId, setId);

      if (restValue > 0) {
        this.lastLoggedSetForRestUpdate = this.getLoggedSet(exerciseId, setId) ?? null;
        setTimeout(async () => {
          const restKey = this.getSetKey(exerciseId, setId);
          if (this.getRestTimerMode() === this.restTimerModeEnum.Compact) {
            this.restStartTimestamps[restKey] = Date.now();
          }
          await this.startRestPeriod(exercise.id, set.id, restValue);
        }, 300);
      }
    }
  }

  /**
   * Checks all sets for an exercise to determine which data columns should be visible.
   * A column is now only considered visible if at least one set has a target value GREATER THAN 0
   * for that metric, or a corresponding "Min" value is set. This keeps the UI clean for
   * exercises where a target might be initialized to 0 (e.g., bodyweight exercises).
   * @param exerciseId: string The id of the exercise in the routine.
   * @returns An object with boolean flags for each potential column.
   */
  public getVisibleSetColumns(exerciseId: string, setId: string): { [key: string]: boolean } {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    const set = exercise?.sets.find(s => s.id === setId);

    const routine = this.routine();

    if (!set || !routine) {
      // Fallback for safety, though it should always find a set.
      return { [METRIC.weight]: false, [METRIC.reps]: false, [METRIC.distance]: false, [METRIC.duration]: false, [METRIC.rest]: false };
    }

    return this.workoutUtilsService.getVisibleSetColumnsByStrings(routine, exerciseId, setId);
  }

  public getVisibleSetColumnsCountForGrid(exerciseId: string, setId: string): number {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);

    // Special handling for exercises in group blocks: count the actual metrics from the computed signal
    if (this.isExerciseInGroupBlock(exerciseId)) {
      // For group blocks, directly count metrics that will be rendered
      const key = this.getSetKey(exerciseId, setId);
      const metrics = this.supersetSummaryMetrics()[key] || [];
      let count = metrics.length + 1;
      return count;
    }

    // For standard exercises, use the existing logic
    let cols = this.getVisibleSetColumns(exerciseId, setId);
    if (this.isEmom(exerciseId)) {
      cols = {
        ...cols,
        [METRIC.rest]: true
      }
    }
    return Object.values(cols).filter(v => v).length;
  }

  public getFieldsForSet(exerciseId: string, setId: string, restExcluded?: boolean): { visible: string[], hidden: string[] } {
    const routine = this.routine();
    if (!routine) return this.workoutUtilsService.defaultHiddenFields();
    // Delegate to the existing service method
    const result = this.workoutUtilsService.getFieldsForSetByStrings(routine, exerciseId, setId);
    if (restExcluded) {
      result.visible = result.visible.filter(field => field !== METRIC.rest)
    }
    return result;
  }


  public canAddField(exerciseId: string, setId: string): boolean {
    const fields = this.getFieldsForSet(exerciseId, setId);
    // Show the button if there are fields that can be added and we are not at the max of 4.
    return fields.hidden.length > 0 && fields.visible.length < this.workoutUtilsService.getDefaultFields().length;
  }

  isFalsyOrZero(value: number | null | undefined): boolean {
    return value === undefined || value === null || value === 0;
  }

  /**
   * Determines if the small "Add Field" button in the set's action area should be visible.
   * This is true only for non-superset exercises with exactly two visible metrics.
   */
  public shouldShowSmallAddButton(exerciseId: string, setId: string): boolean {
    if (this.isExerciseInGroupBlock(exerciseId)) return false;
    const cols = this.getVisibleSetColumns(exerciseId, setId);
    const visibleCount = Object.values(cols).filter(v => v).length;
    return visibleCount === 2;
  }

  public canRemoveAnyField(exerciseId: string, setId: string): boolean {
    const fields = this.getFieldsForSet(exerciseId, setId);
    // Show the button if there is more than one metric to choose from.
    return fields.visible.length > 1;
  }

  public async promptRemoveField(exerciseId: string, setId: string): Promise<void> {
    const currentRoutine = this.routine();
    if (!currentRoutine) return;

    const oldFields = this.getFieldsForSet(exerciseId, setId).visible.filter(field => Object.values(METRIC).includes(field as METRIC));
    const updatedRoutine = await this.workoutUtilsService.promptRemoveFieldByStrings(currentRoutine, exerciseId, setId, true);

    if (updatedRoutine) {
      this.routine.set({ ...updatedRoutine });

      // Find the removed metric
      const newFields = this.workoutUtilsService.getFieldsForSetByStrings(updatedRoutine, exerciseId, setId).visible;
      const removedField = oldFields.find(f => f as METRIC && !newFields.includes(f as METRIC));
      if (removedField) {
        // Remove target and actual
        const set = this.getWorkoutExerciseById(updatedRoutine, exerciseId)?.sets.find(set => set.id === setId);
        if (!set) return;
        switch (removedField) {
          case METRIC.reps: set.targetReps = undefined; break;
          case METRIC.weight: set.targetWeight = undefined; break;
          case METRIC.duration: set.targetDuration = undefined; break;
          case METRIC.distance: set.targetDistance = undefined; break;
          case METRIC.rest: set.targetRest = undefined; break;
        }
        // Remove from performanceInputValues
        this.setPerformanceInputValue(exerciseId, setId, removedField as METRIC, undefined);
      }

      this._prefillPerformanceInputs();
    }
  }


  public async promptAddField(exerciseId: string, setId: string): Promise<void> {
    const currentRoutine = this.routine();
    if (!currentRoutine) return;

    const updatedRoutine = await this.workoutUtilsService.promptAddFieldByStrings(currentRoutine, exerciseId, setId, true);
    if (updatedRoutine) {
      this.routine.set(updatedRoutine);

      // Find the added metric
      const oldFields = this.getFieldsForSet(exerciseId, setId).visible;
      const newFields = this.workoutUtilsService.getFieldsForSetByStrings(updatedRoutine, exerciseId, setId).visible;
      const addedField = newFields.find(f => !oldFields.includes(f));
      if (addedField) {
        // Set default value for target and actual
        const set = this.getWorkoutExerciseById(updatedRoutine, exerciseId)?.sets.find(set => set.id === setId);
        if (!set) return;
        let defaultValue: any;
        switch (addedField) {
          case METRIC.reps: defaultValue = repsToExact(8); set.targetReps = defaultValue; break;
          case METRIC.weight: defaultValue = weightToExact(10); set.targetWeight = defaultValue; break;
          case METRIC.duration: defaultValue = durationToExact(60); set.targetDuration = defaultValue; break;
          case METRIC.distance: defaultValue = distanceToExact(1); set.targetDistance = defaultValue; break;
          case METRIC.rest: defaultValue = restToExact(60); set.targetRest = defaultValue; break;
        }
        // Update performanceInputValues
        this.setPerformanceInputValue(exerciseId, setId, addedField as METRIC, defaultValue);
      }

      this._prefillPerformanceInputs();
      this.scrollToSet(exerciseId, setId);
      // this.toggleMetricsSection(exIndex, setIndex);
    }
  }

  /**
    * UPDATED: Removes a field from ALL sets of an exercise for UI consistency.
    */
  public removeMetricFromSet(exerciseId: string, setId: string, fieldToRemove: string): void {
    const routine = this.routine();
    if (!routine) return;

    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return;
    const set = exercise.sets.find(s => s.id === setId);
    if (!set) return;

    // 1. Update the routine signal to remove the target from the specific set
    this.routine.update(r => {
      if (!r) return r;
      const setToUpdate = this.getWorkoutExerciseById(r, exerciseId)?.sets.find(s => s.id === setId);
      if (!setToUpdate) return r;
      switch (fieldToRemove) {
        case METRIC.weight: setToUpdate.targetWeight = undefined; break;
        case METRIC.reps: setToUpdate.targetReps = undefined; break;
        case METRIC.distance: setToUpdate.targetDistance = undefined; break;
        case METRIC.duration: setToUpdate.targetDuration = undefined; break;
        case METRIC.rest: setToUpdate.targetRest = undefined; break;
        case METRIC.tempo: setToUpdate.targetTempo = undefined; break;
      }
      return { ...r };
    });

    // 2. Update the workout log to remove the performed value, if it exists for that set
    this.currentWorkoutLog.update(log => {
      const exerciseLog = log.exercises?.find(e => e.id === exercise.id);
      if (exerciseLog) {
        // For supersets, we need to find the correct round
        const targetLoggedSetId = this.getPlannedSetId(exercise, set);
        const loggedSet = exerciseLog.sets.find(s => s.plannedSetId === targetLoggedSetId);

        if (loggedSet) {
          switch (fieldToRemove) {
            case METRIC.weight: loggedSet.weightLogged = undefined; break;
            case METRIC.reps: loggedSet.repsLogged = undefined; break;
            case METRIC.distance: loggedSet.distanceLogged = undefined; break;
            case METRIC.duration: loggedSet.durationLogged = undefined; break;
            case METRIC.rest: loggedSet.restLogged = undefined; break;
            case METRIC.tempo: loggedSet.tempoLogged = undefined; break;
          }
        }
      }
      return { ...log };
    });

    // this.toastService.info(`'${fieldToRemove}' field removed from set #${setIndex + 1}.`);
  }

  isSetWarmup(exerciseId: string, setId: string): boolean {
    const routine = this.routine();
    if (!routine) return false;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise || !exercise.sets || exercise.sets.length === 0) return false;
    const set = exercise.sets.find(s => s.id === setId);
    if (!set || !set.type) return false;
    return set.type === 'warmup';
  }


  isSetExpanded(exerciseId: string, setId: string): boolean {
    const key = this.getSetKey(exerciseId, setId);
    return this.expandedSets().has(key);
  }

  // +++ ADD THIS METHOD: Toggles the expanded/collapsed state of a specific set +++
  toggleSetExpansion(exerciseId: string, setId: string, event: Event): void {
    if (event) {
      const target = event.target as HTMLElement;
      if (target.closest('button') || ['INPUT', 'TEXTAREA', 'SELECT'].includes(target.tagName)) {
        return;
      }

      // Ignore clicks inside the #exerciseCard
      if (target.closest('#exerciseCard')) {
        return;
      }
    }
    event.stopPropagation(); // Prevent the main exercise card from toggling

    const routine = this.routine();
    if (!routine) return;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    const plannedSet = exercise?.sets.find(s => s.id === setId);
    if (!exercise || !plannedSet) return;

    const key = this.getSetKey(exercise.id, plannedSet.id);

    this.expandedSets.update(currentSet => {
      const newSet = new Set(currentSet); // Create a new instance for signal change detection
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        newSet.add(key);
        this.scrollToSet(exerciseId, setId);
      }
      return newSet;
    });
    this.closeSetActionMenu();
  }

  // +++ ADD THIS METHOD: Gets a summary of the set for the collapsed view +++
  getSetSummary(exerciseId: string, setId: string): string {
    const routine = this.routine();
    if (!routine) return '';
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return '';
    const plannedSet = exercise.sets.find(s => s.id === setId);
    if (!plannedSet) return '';
    const loggedSet = this.getLoggedSet(exerciseId, setId);
    const key = this.getSetKey(exerciseId, setId);
    const userInputs = this.performanceInputValues()[key] || {};

    // Priority: userInputs > loggedSet > plannedSet
    const weight = userInputs.actualWeight ?? loggedSet?.weightLogged ?? plannedSet.targetWeight;
    const reps = userInputs.actualReps ?? loggedSet?.repsLogged ?? plannedSet.targetReps;
    const distance = userInputs.actualDistance ?? loggedSet?.distanceLogged ?? plannedSet.targetDistance;
    const duration = userInputs.actualDuration ?? loggedSet?.durationLogged ?? plannedSet.targetDuration;
    const rest = userInputs.actualRest ?? loggedSet?.restLogged ?? plannedSet.targetRest;
    const tempo = userInputs.tempoLogged ?? loggedSet?.tempoLogged ?? plannedSet.targetTempo;

    let parts: string[] = [];

    // Reps & Weight
    if (
      reps !== undefined && reps !== null &&
      weight !== undefined && weight !== null
    ) {
      const repsType: RepsTargetType = reps.type;
      let repsStr = '';
      if (repsType === RepsTargetType.exact || repsType === RepsTargetType.range) {
        repsStr = `${repsTargetAsString(reps)} reps`;
      } else if (repsType === RepsTargetType.max || repsType === RepsTargetType.amrap) {
        repsStr = `${repsType.toUpperCase()} reps`;
      }
      let weightStr = '';
      if (getWeightValue(weight) > 0) {
        weightStr = this.weightUnitPipe.transform(getWeightValue(weight)) ?? '';
      } else if (
        weight &&
        weight.type === WeightTargetType.bodyweight
      ) {
        weightStr = 'BW';
      }
      if (repsStr && weightStr) {
        parts.push(`${repsStr} @ ${weightStr}`);
      } else if (repsStr) {
        parts.push(repsStr);
      } else if (weightStr) {
        parts.push(weightStr);
      }
    } else {
      // Fallback for reps or weight alone
      if (weight !== undefined && weight !== null && getWeightValue(weight) > 0) {
        parts.push(`${this.weightUnitPipe.transform(getWeightValue(weight))}`);
      }
      if (weight && getWeightValue(weight) === 0) {
        parts.push('BW');
      }
      if (reps !== undefined && reps !== null) {
        const repsType: RepsTargetType = reps.type;
        if (repsType === RepsTargetType.exact || repsType === RepsTargetType.range) {
          parts.push(`${repsTypeToReps(reps)} reps`);
        } else if (repsType === RepsTargetType.max || repsType === RepsTargetType.amrap) {
          parts.push(`${repsType.toUpperCase()} reps`);
        }
      }
    }

    // Distance
    if (distance !== undefined && distance !== null && getDistanceValue(distance) > 0) {
      parts.push(`${getDistanceValue(distance)} ${this.unitsService.getDistanceUnitSuffix()}`);
    }

    // Duration
    if (duration !== undefined && duration !== null && getDurationValue(duration) > 0) {
      parts.push(this.formatSecondsToTime(getDurationValue(duration)));
    }

    // Rest
    if (rest !== undefined && rest !== null && getRestValue(rest) > 0) {
      parts.push(`Rest: ${this.formatSecondsToTime(getRestValue(rest))}`);
    }

    // Tempo
    if (tempo) {
      parts.push(`T: ${tempo}`);
    }

    if (parts.length === 0) return 'Tap to log...';
    return parts.join(' | ');
  }

  getSupersetRoundSummary(exerciseId: string, roundId: string): string {
    const routine = this.routine();
    if (!routine) return '';

    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return '';

    if (!this.isExerciseInGroupBlock(exerciseId)) return '';

    const exercisesInGroup = this.getSupersetExercises(exerciseId);

    // For each exercise in the group, get the summary for the set at roundIndex (metrics only)
    const parts = exercisesInGroup.map((ex) => {
      const exIdx = this.getOriginalExId(ex.id);
      if (exIdx === '') return '';
      // Use the existing getSetSummary for each set in the round
      // Remove the exercise name from the summary
      return this.getSetSummary(exIdx, roundId);
    }).filter(Boolean);

    return parts.join(' | ');
  }


  /**
   * Checks if a standard set is time-based and should display a timer.
   * @param exerciseId: string The id of the exercise.
   * @param setId The id of the set.
   * @returns True if the set is a timed set.
   */
  public isTimedSet(exerciseId: string, setId: string): boolean {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    const set = this.getSetById(this.routine(), exerciseId, setId);
    // A set is timed if it's NOT in a group block and has a duration target > 0
    return !!(!this.isExerciseInGroupBlock(exerciseId) && set && (getDurationValue(set.targetDuration) ?? 0) > 0);
  }

  /**
   * Helper to find the index of the first round in a superset that has not been logged yet.
   * @param exerciseId: string The id of the starting exercise of the superset.
   * @returns The index of the first incomplete round, or -1 if all are complete.
   */
  protected findFirstIncompleteRoundIndex(exerciseId: string): number {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!this.isExerciseInGroupBlock(exerciseId)) {
      return -1;
    }
    return exercise!.sets.findIndex((round) => !this.isRoundCompleted(exerciseId, round.id));
  }


  /**
   * Determines the dynamic CSS classes for a superset round card.
   * Gives a special "focused" style to the first incomplete round when it's expanded.
   * @param exerciseId: string The id of the exercise.
   * @param roundId The id of the round.
   * @returns An object compatible with [ngClass].
   */
  public getRoundClasses(exerciseId: string, roundId: string): any {
    const isCompleted = this.isRoundCompleted(exerciseId, roundId);
    const isExpanded = this.isRoundExpanded(exerciseId, roundId);
    const firstIncompleteIndex = this.findFirstIncompleteRoundIndex(exerciseId);

    const isFocused = isExpanded && this.findCurrentSetIndex(roundId) === firstIncompleteIndex;

    if (isFocused) {
      return {
        // 'rounded-xl p-2 transition-all duration-300': true,
        'rounded-xl p-2': true,
        'ring-2 ring-yellow-400 dark:ring-yellow-500 z-10': true,
        'bg-gray-100 dark:bg-gray-900': true
      };
    }

    if (isCompleted) {
      return {
        'rounded-xl p-2': true,
        // 'rounded-xl p-2 transition-all duration-300': true,
        'bg-green-300 dark:bg-green-700 border border-green-300 dark:border-green-800': true,
      };
    }

    if (isExpanded) {
      return {
        // 'rounded-xl p-2 py-1 transition-all duration-300': true,
        'rounded-xl p-2 py-1': true,
        'bg-gray-100 dark:bg-gray-900': true
      }
    }

    return {
      // 'rounded-xl p-2 py-1 transition-all duration-300': true,
      'rounded-xl p-2 py-1': true,
      'bg-gray-100 dark:bg-gray-800': true,
    };
  }

  /**
     * Gets the current timer state for a specific standard set.
     * It prioritizes the user's input for the duration if it differs from the planned target.
     */
  getSetTimerState(exerciseId: string, setId: string): { status: TimerSetState, remainingTime: number } {
    if (this.isSetCompleted(exerciseId, setId)) {
      return { status: TimerSetState.Completed, remainingTime: 0 };
    }
    const key = this.getSetKey(exerciseId, setId);
    const allTimerStates = this.setTimerState();

    // If a timer is already active (running/paused), return its current state immediately.
    if (allTimerStates[key]) {
      return allTimerStates[key];
    }

    // --- PRIORITY LOGIC FOR IDLE STATE ---
    // If the timer is idle, determine the correct starting duration.
    const userInputs = this.performanceInputValues()[key];
    let duration: number;

    // 1. Prioritize the user's typed input if it exists.
    if (userInputs && userInputs.actualDuration !== undefined && userInputs.actualDuration !== null) {
      duration = getDurationValue(userInputs.actualDuration);
    } else {
      // 2. Fall back to the planned target duration from the routine (using block-aware method).
      const set = this.getSetById(this.routine(), exerciseId, setId);
      duration = getDurationValue(set?.targetDuration ?? durationToExact(0));
    }

    // Return the idle state with the correctly prioritized duration.
    return { status: TimerSetState.Idle, remainingTime: duration };
  }

  /**
   * Central handler for the timed set button clicks (play/pause/resume).
   */
  handleSetTimerAction(exerciseId: string, setId: string, event: Event): void {
    event.stopPropagation();
    const key = this.getSetKey(exerciseId, setId);
    const state = this.getSetTimerState(exerciseId, setId);

    switch (state.status) {
      case TimerSetState.Idle:
      case TimerSetState.Paused:
        this.startSetTimer(exerciseId, setId, key);
        break;
      case TimerSetState.Running:
        this.pauseSetTimer(key);
        break;
    }
  }

  /**
   * Starts or resumes the timer for a specific standard set.
   * It now uses getSetTimerState to ensure it starts with the correct duration,
   * respecting any user input.
   */
  private startSetTimer(exerciseId: string, setId: string, key: string): void {
    this.lastBeepSecond = null;
    const state = this.getSetTimerState(exerciseId, setId);
    const duration = state.remainingTime;

    this.audioService.playSound(AUDIO_TYPES.referee);
    this.setTimerState.update(states => {
      if (!states[key]) {
        states[key] = { status: TimerSetState.Running, remainingTime: duration };
      } else {
        states[key].status = TimerSetState.Running;
      }
      return { ...states };
    });

    this.setTimerSub?.unsubscribe();

    this.setTimerSub = timer(1000, 1000).subscribe(() => {
      const currentRemaining = this.setTimerState()[key]?.remainingTime;

      if (currentRemaining !== undefined && currentRemaining > 0) {
        // Decrement first
        this.setTimerState.update(states => {
          states[key].remainingTime--;
          return { ...states };
        });

        // Play sound for the NEW remaining time (after decrement)
        const newRemaining = this.setTimerState()[key]?.remainingTime;
        // +++ Only play countdown sound if newRemaining > 0 +++
        if (newRemaining > 0) {
          this.playCountdownSound(newRemaining);
        } else {
          this.playEndSound();
          //  Use block-aware method to get exercise and set
          const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
          if (!exercise) return;
          const set = this.getSetById(this.routine(), exerciseId, setId);
          if (!set) return;
          if (!this.isSetCompleted(exerciseId, setId)) {
            // this.toastService.success(`Set #${setIndex + 1} complete!`);
            setTimeout(() => {
              this.toggleSetCompletion(exercise, set, exerciseId, setId);
              this.setTimerSub?.unsubscribe();
              this.setTimerState.update(states => {
                delete states[key];
                return { ...states };
              });
            }, 150);
          }
        }
      }
    });
  }

  /**
   * Pauses the currently active standard set timer.
   */
  private pauseSetTimer(key: string): void {
    this.setTimerSub?.unsubscribe();
    this.setTimerState.update(states => {
      if (states[key]) {
        states[key].status = TimerSetState.Paused;
      }
      return { ...states };
    });
  }

  /**
   * UI helper to get the text for the timed set button.
   */
  getSetTimerButtonText(exerciseId: string, setId: string): string {
    const state = this.getSetTimerState(exerciseId, setId);
    const textMap = { [TimerSetState.Idle]: 'START', [TimerSetState.Running]: 'PAUSE', [TimerSetState.Paused]: 'RESUME', [TimerSetState.Completed]: 'DONE' };
    return textMap[state.status];
  }

  /**
   * UI helper to get the icon for the timed set button.
   */
  getSetTimerButtonIcon(exerciseId: string, setId: string): string {
    const state = this.getSetTimerState(exerciseId, setId);
    const iconMap = { [TimerSetState.Idle]: 'play', [TimerSetState.Running]: 'pause', [TimerSetState.Paused]: 'play', [TimerSetState.Completed]: 'check' };
    return iconMap[state.status];
  }

  /**
   * UI helper to get the CSS class for the timed set button.
   */
  getSetTimerButtonClass(exerciseId: string, setId: string): string {
    const state = this.getSetTimerState(exerciseId, setId);
    const classMap = {
      [TimerSetState.Idle]: 'bg-teal-500 hover:bg-teal-600',
      [TimerSetState.Running]: 'bg-yellow-500 hover:bg-yellow-600',
      [TimerSetState.Paused]: 'bg-teal-500 hover:bg-teal-600 animate-pulse',
      [TimerSetState.Completed]: 'bg-green-500 hover:bg-green-600',
    };
    return classMap[state.status];
  }

  cardHeaderText(): string {
    const routine = this.routine();
    const sessioneState = this.sessionState();

    if (!routine || routine === undefined) {
      return '';
    }
    const sessionStatePaused = sessioneState === 'paused' ? ' animate-pulse' : '';
    return !!routine.cardColor ? 'text-white' + sessionStatePaused : '' + sessionStatePaused;
  }

  isSessionOverviewVisible = signal(false);
  openSessionOverviewModal(): void {
    this.isSessionOverviewVisible.set(true);
  }

  closeSessionOverviewModal(): void {
    this.isSessionOverviewVisible.set(false);
  }

  /**
   * Pre-populates the `performanceInputValues` signal with the initial planned
   * values for every set in the routine. This ensures that if a user logs a
   * set without interacting with the inputs, the planned targets are logged correctly.
   */
  private _prefillPerformanceInputs(alignActualToTarget?: boolean): void {
    const routine = this.routine();
    if (!routine) return;

    const previousInputs = this.performanceInputValues();
    const initialValues: { [key: string]: Partial<ExerciseCurrentExecutionSetParams> } = {};

    // Use the block-aware method to get all exercises
    const allExercises = this.workoutService.getExercisesFlat(routine);

    // Pre-fill for all exercises (blocks are already flattened)
    allExercises.forEach((exercise) => {
      exercise.sets.forEach((plannedSet) => {
        const key = this.getSetKey(exercise.id, plannedSet.id);
        const prev = previousInputs[key] || {};

        if (alignActualToTarget) {
          prev.actualReps = plannedSet.targetReps ?? prev.actualReps;
          prev.actualWeight = plannedSet.targetWeight ?? prev.actualWeight;
          prev.actualDistance = plannedSet.targetDistance ?? prev.actualDistance;
          prev.actualDuration = plannedSet.targetDuration ?? prev.actualDuration;
          prev.actualRest = plannedSet.targetRest ?? prev.actualRest;
        }

        initialValues[key] = {
          actualReps: prev.actualReps ?? plannedSet.targetReps ?? undefined,
          actualWeight: prev.actualWeight ?? plannedSet.targetWeight ?? undefined,
          actualDistance: prev.actualDistance ?? plannedSet.targetDistance ?? undefined,
          actualDuration: prev.actualDuration ?? plannedSet.targetDuration ?? undefined,
          actualRest: prev.actualRest ?? plannedSet.targetRest ?? undefined,
          notes: prev.notes ?? plannedSet.notes ?? undefined,
          tempoLogged: prev.tempoLogged ?? plannedSet.targetTempo ?? undefined,
        };
      });
    });

    this.performanceInputValues.set(initialValues);
  }

  /**
 * A computed signal that creates a "display-ready" version of the routine.
 * It pre-calculates the progressive overload suggestions for every set that needs one.
 * This is highly efficient because it only re-runs when the routine or the log changes.
 */
  suggestedRoutine = computed<Routine | null | undefined>(() => {
    const routine = this.routine();
    const log = this.currentWorkoutLog(); // Dependency on the log is crucial

    if (!routine) {
      return routine; // Return null or undefined if no routine is loaded
    }

    // Create a new routine object to avoid mutating the original signal's value
    const newRoutine: Routine = {
      ...routine,
      exercises: routine.exercises.map((exercise) => ({
        ...exercise,
        sets: exercise.sets.map((set, setIndex) => {
          // This is the core logic from your old getSetTargetDisplay method
          if (setIndex === 0) {
            return set; // First set always uses the planned values
          }

          const roundIndexForLog = this.isSuperSet(exercise.id) ? setIndex - 1 : 0;
          const previousLoggedSet = this.getLoggedSet(exercise.id, set.id);

          if (previousLoggedSet) {
            // If the previous set was logged, return the suggested parameters for the current set
            return this.workoutService.suggestNextSetParameters(previousLoggedSet, set);
          } else {
            // Otherwise, return the original planned set
            return set;
          }
        })
      }))
    };

    return newRoutine;
  });



  private intervalId: any = null;

  onShortPressIncrement(exerciseId: string, setId: string, field: METRIC): void {
    this.incrementValue(exerciseId, setId, field);
  }

  onLongPressIncrement(exerciseId: string, setId: string, field: METRIC): void {
    this.intervalId = setInterval(() => this.incrementValue(exerciseId, setId, field), 200);
  }

  onShortPressDecrement(exerciseId: string, setId: string, field: METRIC): void {
    this.decrementValue(exerciseId, setId, field);
  }

  onLongPressDecrement(exerciseId: string, setId: string, field: METRIC): void {
    this.intervalId = setInterval(() => this.decrementValue(exerciseId, setId, field), 200);
  }

  onPressRelease(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  private incrementValue(exerciseId: string, setId: string, field: METRIC): void {
    const settings = this.appSettingsService.getSettings();
    const key = this.getSetKey(exerciseId, setId);
    const inputKey = `${key}-${field}`;
    this.invalidInputs.update(s => { s.delete(inputKey); return s; });

    // Determine step size
    let step: number;
    switch (field) {
      case METRIC.weight: step = settings.weightStep || 1; break;
      case METRIC.duration: step = settings.durationStep || 5; break;
      case METRIC.rest: step = settings.restStep || 5; break;
      case METRIC.distance: step = settings.distanceStep || 0.1; break;
      default: step = 1; // Default for reps
    }

    // Get the current value using the new getter
    let currentValue = this.getPerformanceInputValue(exerciseId, setId, field);
    let newValue: AnyTarget | string;

    // Handle different metric types
    if (field === METRIC.duration) {
      currentValue = typeof currentValue === 'string' ? this.parseTimeToSeconds(currentValue) : getDurationValue(currentValue) || 0;
      newValue = durationToExact(Math.max(0, parseFloat((currentValue + step).toFixed(2))));
    } else if (field === METRIC.rest) {
      currentValue = typeof currentValue === 'string' ? this.parseTimeToSeconds(currentValue) : getRestValue(currentValue) || 0;
      newValue = restToExact(Math.max(0, parseFloat((currentValue + step).toFixed(2))));
    } else if (field === METRIC.weight) {
      currentValue = getWeightValue(currentValue) || 0;
      newValue = weightToExact(Math.max(0, parseFloat((currentValue + step).toFixed(2))));
    } else if (field === METRIC.distance) {
      currentValue = getDistanceValue(currentValue) || 0;
      newValue = distanceToExact(Math.max(0, parseFloat((currentValue + step).toFixed(2))));
    } else if (field === METRIC.reps) {
      currentValue = repsTypeToReps(currentValue) || 0;
      newValue = repsToExact(Math.max(0, parseInt((currentValue + step).toFixed(0), 10)));
    } else {
      newValue = '';
    }

    // Use your setter to update and validate
    // For REST metric in supersets, apply special logic
    if (field === METRIC.rest && this.isSuperSet(exerciseId)) {
      this.setPerformanceInputValueForSupersetRest(exerciseId, setId, newValue);
    } else {
      this.setPerformanceInputValue(exerciseId, setId, field, newValue);
    }

    if (field === METRIC.duration) {
      const durationValue = typeof newValue === 'number' ? newValue : getDurationValue(newValue as DurationTarget);
      this.resetTimerIfActive(exerciseId, setId, durationValue);
    }
    if (field === METRIC.rest) {
      if (this.getRestTimerMode() === this.restTimerModeEnum.Compact) {
        const restKey = this.getSetKey(exerciseId, setId);
        this.restStartTimestamps[restKey] = 0;
      }
    }
  }

  private decrementValue(exerciseId: string, setId: string, field: METRIC): void {
    const settings = this.appSettingsService.getSettings();
    const key = this.getSetKey(exerciseId, setId);
    const inputKey = `${key}-${field}`;
    this.invalidInputs.update(s => { s.delete(inputKey); return s; });

    // Determine step size
    let step: number;
    switch (field) {
      case METRIC.weight: step = settings.weightStep || 1; break;
      case METRIC.duration: step = settings.durationStep || 5; break;
      case METRIC.rest: step = settings.restStep || 5; break;
      case METRIC.distance: step = settings.distanceStep || 0.1; break;
      default: step = 1; // Default for reps
    }

    // Get the current value using the new getter
    let currentValue = this.getPerformanceInputValue(exerciseId, setId, field);
    let newValue: AnyTarget | string;

    // Handle different metric types
    if (field === METRIC.duration) {
      currentValue = typeof currentValue === 'string' ? this.parseTimeToSeconds(currentValue) : getDurationValue(currentValue) || 0;
      newValue = durationToExact(Math.max(0, parseFloat((currentValue - step).toFixed(2))));
    } else if (field === METRIC.rest) {
      currentValue = typeof currentValue === 'string' ? this.parseTimeToSeconds(currentValue) : getRestValue(currentValue) || 0;
      newValue = restToExact(Math.max(0, parseFloat((currentValue - step).toFixed(2))));
    } else if (field === METRIC.weight) {
      currentValue = getWeightValue(currentValue) || 0;
      newValue = weightToExact(Math.max(0, parseFloat((currentValue - step).toFixed(2))));
    } else if (field === METRIC.distance) {
      currentValue = getDistanceValue(currentValue) || 0;
      newValue = distanceToExact(Math.max(0, parseFloat((currentValue - step).toFixed(2))));
    } else if (field === METRIC.reps) {
      currentValue = repsTypeToReps(currentValue) || 0;
      newValue = repsToExact(Math.max(0, parseInt((currentValue - step).toFixed(0), 10)));
    } else {
      newValue = '';
    }

    // Use your setter to update and validate
    // For REST metric in supersets, apply special logic
    if (field === METRIC.rest && this.isSuperSet(exerciseId)) {
      this.setPerformanceInputValueForSupersetRest(exerciseId, setId, newValue);
    } else {
      this.setPerformanceInputValue(exerciseId, setId, field, newValue);
    }

    if (field === METRIC.duration) {
      const durationValue = typeof newValue === 'number' ? newValue : getDurationValue(newValue as DurationTarget);
      this.resetTimerIfActive(exerciseId, setId, durationValue);
    }
    if (field === METRIC.rest) {
      if (this.getRestTimerMode() === this.restTimerModeEnum.Compact) {
        const restKey = this.getSetKey(exerciseId, setId);
        this.restStartTimestamps[restKey] = 0;
      }
    }
  }

  /**
 * Special handler for REST metric in supersets.
 * - For standard supersets: applies REST only to the last exercise in the round
 * - For EMOM supersets: does nothing
 */
  private setPerformanceInputValueForSupersetRest(exerciseId: string, setId: string, value: any): void {
    //  Use block-aware method to check if exercise is in a group
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!this.isExerciseInGroupBlock(exerciseId)) return;

    // If EMOM, do nothing
    if (this.isEmom(exerciseId)) return;

    // For standard supersets, apply REST only to the last exercise
    const supersetExercises = this.getSupersetExercises(exerciseId);
    const lastExercise = supersetExercises[supersetExercises.length - 1];

    //  No need to find index, just use the lastExercise.id directly
    // Apply REST value only to the last exercise
    this.setPerformanceInputValue(lastExercise.id, setId, METRIC.rest, value);
  }

  protected resetTimerIfActive(exerciseId: string, setId: string, newDuration?: number): void {
    const key = this.getSetKey(exerciseId, setId);
    const timerState = this.setTimerState()[key];

    // Only reset if timer exists and is running or paused
    if (timerState && (timerState.status === TimerSetState.Running || timerState.status === TimerSetState.Paused)) {
      // If newDuration is not provided, fall back to planned targetDuration
      let durationToSet = newDuration;
      if (durationToSet === undefined) {
        //  Use block-aware method to get set
        const set = this.getSetById(this.routine(), exerciseId, setId);
        durationToSet = set ? getDurationValue(set.targetDuration) : 0;
      }

      // Update the timer state with the new duration
      this.setTimerState.update(states => {
        states[key] = {
          ...states[key],
          remainingTime: durationToSet
        };
        return { ...states };
      });

      // If it was running, restart the timer with the new duration
      if (timerState.status === TimerSetState.Running) {
        this.setTimerSub?.unsubscribe();
        this.startSetTimer(exerciseId, setId, key);
      }
    }
  }

  private isManualRestActive = false;
  restTimerMode = signal<TIMER_MODES>(TIMER_MODES.timer);

  async openManualRestTimer(): Promise<void> {
    // First, close the menu it was triggered from.
    // this.toggleMainSessionActionMenu(null);

    // Step 1: Ask the user which type of timer they want.
    const choice = await this.alertService.showConfirmationDialog(
      this.translate.instant('compactPlayer.alerts.chooseTimerTitle'),
      this.translate.instant('compactPlayer.alerts.chooseTimerMessage'),
      [
        { text: this.translate.instant('compactPlayer.actions.countdown'), role: 'confirm', data: TIMER_MODES.timer, icon: 'duration' },
        { text: this.translate.instant('compactPlayer.actions.stopwatch'), role: 'confirm', data: TIMER_MODES.stopwatch, icon: 'stopwatch' }
      ]
    );

    if (!choice || !choice.data) {
      return; // User cancelled the selection
    }

    // Step 2: Branch logic based on the user's choice.
    if (choice.data === TIMER_MODES.timer) {
      // User chose COUNTDOWN, so we prompt for a duration.
      const result = await this.alertService.showPromptDialog(
        this.translate.instant('compactPlayer.alerts.manualRestTitle'),
        this.translate.instant('compactPlayer.alerts.manualRestMessage'),
        [{
          name: 'duration',
          type: 'number',
          placeholder: 'Seconds',
          value: 60,
          attributes: { min: '1', required: true }
        }] as AlertInput[],
        this.translate.instant('compactPlayer.alerts.startRest'),
        this.translate.instant('common.cancel')
      );

      if (result && result['duration']) {
        const duration = Number(result['duration']);
        if (duration > 0) {
          this.isManualRestActive = true;
          this.restTimerMode.set(TIMER_MODES.timer); // Set mode to countdown
          this.restDuration.set(duration);
          this.restTimerMainText.set(this.translate.instant('compactPlayer.manualRest'));
          this.restTimerNextUpText.set(this.translate.instant('compactPlayer.takeABreak'));
          this.isRestTimerVisible.set(true);
        }
      }
    } else if (choice.data === TIMER_MODES.stopwatch) {
      // User chose STOPWATCH, so we start it immediately.
      this.isManualRestActive = true;
      this.restTimerMode.set(TIMER_MODES.stopwatch); // Set mode to stopwatch
      this.restTimerMainText.set(this.translate.instant('compactPlayer.manualRest'));
      this.restTimerNextUpText.set(this.translate.instant('compactPlayer.takeABreak'));
      this.isRestTimerVisible.set(true);
    }
  }

  handleStopwatchStopped(): void {
    this.isRestTimerVisible.set(false);

    if (this.isManualRestActive) {
      this.isManualRestActive = false;
      // Optional: You could show a toast here like "Rest complete: 1:30"
    }
  }

  availableSetTypes: { value: string, label: string }[] = [
    { value: SET_TYPE.standard, label: this.translate.instant('workoutBuilder.setTypes.standard') },
    { value: SET_TYPE.warmup, label: this.translate.instant('workoutBuilder.setTypes.warmup') },
    { value: SET_TYPE.superset, label: this.translate.instant('workoutBuilder.setTypes.superset') },
    { value: SET_TYPE.amrap, label: this.translate.instant('workoutBuilder.setTypes.amrap') },
    { value: SET_TYPE.dropset, label: this.translate.instant('workoutBuilder.setTypes.dropset') },
    { value: SET_TYPE.failure, label: this.translate.instant('workoutBuilder.setTypes.failure') },
    { value: SET_TYPE.myorep, label: this.translate.instant('workoutBuilder.setTypes.myorep') },
    { value: SET_TYPE.restpause, label: this.translate.instant('workoutBuilder.setTypes.restpause') },
    { value: SET_TYPE.custom, label: this.translate.instant('workoutBuilder.setTypes.custom') }
  ];

  getSetType(exerciseId: string, setId: string): SET_TYPE | undefined {
    const routine = this.routine();
    if (!routine) {
      return undefined;
    }
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise || !exercise.sets || exercise.sets.length === 0) {
      return undefined;
    }
    const set = exercise.sets.find(s => s.id === setId);
    if (!set || !set.type) {
      return undefined;
    }
    return set.type as SET_TYPE;
  }

  updateSetType(exerciseId: string, setId: string, newType: SET_TYPE): void {
    this.routine.update(routine => {
      if (!routine) return routine;

      const exercise = this.getWorkoutExerciseById(routine, exerciseId);
      if (exercise) {
        const set = exercise.sets.find(s => s.id === setId);
        if (set) {
          set.type = newType;
          this.toastService.info(
            this.translate.instant('compactPlayer.toasts.setTypeChanged', {
              setNumber: exercise.sets.indexOf(set) + 1
            })
          );
        }
      }

      return { ...routine };
    });
  }

  isRestModalVisible = signal(false);
  activeRestModalContext = signal<{ exerciseId: string, setId: string } | null>(null);
  openRestModal(exerciseId: string, setId: string, event: Event): void {
    event.stopPropagation();
    if (this.getRestDataForExercise(exerciseId, setId) && this.getRestDataForExercise(exerciseId, setId).exerciseId === undefined) {
      this.toastService.error("NOT FOUND");
      return;
    }
    const data = {
      exerciseId: this.getRestDataForExercise(exerciseId, setId).exerciseId as string,
      setId: this.getRestDataForExercise(exerciseId, setId).setId as string,
    }
    this.activeRestModalContext.set({ ...data });
    this.isRestModalVisible.set(true);
  }

  getRestDataForExercise(exerciseId: string, setId: string): { exerciseId: string | undefined, setId: string | undefined } {
    const routine = this.routine();
    if (!routine || !routine.exercises || !routine.exercises.length) {
      return { exerciseId: undefined, setId: undefined };
    }

    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return { exerciseId: undefined, setId: undefined };

    if (!this.isExerciseInGroupBlock(exerciseId)) {
      // Standard exercise: just return the exerciseId and setId as-is
      return { exerciseId, setId };
    } else {
      // In a group block: find the last exercise in the group for this round
      const groupExercises = this.getSupersetExercises(exerciseId);
      if (groupExercises.length === 0) return { exerciseId: undefined, setId: undefined };
      const lastExercise = groupExercises[groupExercises.length - 1];
      return { exerciseId: lastExercise.id, setId };
    }
  }

  closeRestModal(): void {
    this.isRestModalVisible.set(false);
    this.activeRestModalContext.set(null); // Clear context on close
  }

  protected isGhostFieldVisible(exerciseId: string, setId: string, fieldOrder?: METRIC[],): boolean {
    const visibleFields: METRIC[] | undefined = this.getSetFieldOrderNoRest(exerciseId, setId);
    if (!visibleFields) return false;
    return !!(!this.isSetCompleted(exerciseId, setId) && this.canAddField(exerciseId, setId) && (visibleFields.length % 2 === 1 && visibleFields.length > 1));
    // return !!(this.isEditableMode() && !this.isSuperSet(exerciseId) && fieldOrder && fieldOrder.length !== undefined && ((fieldOrder.length <= 1) || (fieldOrder.length > 2 && fieldOrder.length % 2 == 1)));
  }

  protected getSetFieldOrder(exerciseId: string, setId: string): METRIC[] | undefined {
    const routine = this.routine();
    if (!routine || !routine.exercises || !routine.exercises.length) return undefined;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise || !exercise.sets || !exercise.sets.length) return undefined;
    const set = exercise.sets.find(s => s.id === setId);
    return set ? set.fieldOrder : undefined;
  }

  protected getSetFieldOrderNoRest(exerciseId: string, setId: string): METRIC[] | undefined {
    const setFieldOrder = this.getSetFieldOrder(exerciseId, setId);
    return setFieldOrder ? setFieldOrder.filter(field => field !== METRIC.rest) : undefined;
  }

  protected getExerciseSetsLength(exerciseId: string): number {
    const routine = this.routine();
    if (!routine || !routine.exercises || !routine.exercises.length) return 0;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    return exercise?.sets?.length || 0;
  }


  // Tracks which exercise's "Set All" panel is currently expanded.
  expandedSetAllPanel = signal<string | null>(null);

  // Signals to hold the temporary values from the "Set All" input fields.
  repsToSetForAll = signal<number | null>(null);
  weightToSetForAll = signal<number | null>(null);
  durationToSetForAll = signal<number | null>(null);
  distanceToSetForAll = signal<number | null>(null);
  restToSetForAll = signal<number | null>(null);
  tempoToSetForAll = signal<string | null>(null);
  invalidInputs = signal<Set<string>>(new Set());

  /**
* Toggles the visibility of the "Set All" collapsible panel for a given exercise.
* @param exerciseId: string The id of the exercise.
* @param event The mouse event to stop it from propagating and collapsing the card.
*/
  toggleSetAllPanel(exerciseId: string, event: Event): void {
    event.stopPropagation();
    this.expandedSetAllPanel.update(current => (current === exerciseId ? null : exerciseId));
  }

  /**
   * Checks all sets within an exercise to determine which data columns should be visible in the UI.
   * A column is considered visible if at least one set has a target value for that metric.
   * @param exerciseControl The FormGroup for the exercise.
   * @returns An object with boolean flags for each potential column (reps, weight, etc.).
   */
  public getVisibleColumnsForExercise(exerciseId: string): { [key: string]: boolean } {
    const routine = this.routine();
    if (!routine) return {};
    return this.workoutUtilsService.getVisibleExerciseColumnsByStrings(routine, exerciseId);
  }

  /**
 * Applies the values entered in the "Set All" panel to every set of a specific exercise.
 * If the exercise is part of a superset, the values are applied to all sets (rounds)
 * for ALL exercises within that superset group.
 * This now updates ALL sets, including logged ones.
 * @param exerciseId: string The id of the exercise where the action was triggered.
 */
  applyToAllSets(exerciseId: string): void {
    const routine = this.routine();
    if (!routine) return;

    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return;

    // Determine if this exercise is part of a superset
    const isSuperset = this.isExerciseInGroupBlock(exerciseId);

    // Helper to sanitize and validate numbers (no negatives, no NaN)
    function sanitizeNumber(val: any, step: number, allowDecimals: boolean = false): number | null {
      if (val === null || val === undefined) return null;
      let num = Number(val);
      if (isNaN(num)) return null;
      num = Math.abs(num); // Always positive

      if (allowDecimals) {
        return Math.round(num * 100) / 100;
      } else {
        return Math.round(num / step) * step;
      }
    }

    // 1. Gather values to apply
    const reps = sanitizeNumber(this.repsToSetForAll(), this.repsStep);
    const weight = sanitizeNumber(this.weightToSetForAll(), this.weightStep, true);
    const duration = sanitizeNumber(this.durationToSetForAll(), this.durationStep);
    const distance = this.distanceToSetForAll();
    const rest = sanitizeNumber(this.restToSetForAll(), this.restStep);
    const tempo = this.tempoToSetForAll() !== null && this.tempoToSetForAll()!.trim() !== '' ? this.tempoToSetForAll()!.trim() : null;

    // 2. Build a list of metrics to apply
    const metricsToApply: { metric: METRIC, value: any }[] = [];
    if (reps !== null) metricsToApply.push({ metric: METRIC.reps, value: repsToExact(reps) });
    if (weight !== null) metricsToApply.push({ metric: METRIC.weight, value: weightToExact(weight) });
    if (duration !== null) metricsToApply.push({ metric: METRIC.duration, value: durationToExact(duration) });
    if (distance !== null) metricsToApply.push({ metric: METRIC.distance, value: distanceToExact(distance) });
    if (rest !== null) metricsToApply.push({ metric: METRIC.rest, value: restToExact(rest) });
    if (tempo !== null) metricsToApply.push({ metric: METRIC.tempo, value: tempo });

    if (metricsToApply.length === 0) {
      this.toastService.info("No values entered to apply.");
      return;
    }

    // 3. Identify all target exercises (either a single exercise or all in a group block)
    let targetExercises: WorkoutExercise[] = [];
    if (isSuperset) {
      // Get all exercises in the same block
      targetExercises = this.getSupersetExercises(exerciseId);
    } else {
      targetExercises = [exercise];
    }

    let updatedSetsCount = 0;

    // 4. Update the routine
    this.routine.update(r => {
      if (!r) return r;
      const targetExerciseIds = new Set(targetExercises.map(ex => ex.id));

      const newExercises = r.exercises.map(exercise => {
        if (!targetExerciseIds.has(exercise.id)) return exercise;

        const newSets = exercise.sets.map((set) => {
          updatedSetsCount++;
          const newSet = { ...set };

          metricsToApply.forEach(({ metric, value }) => {
            // Patch the target value
            switch (metric) {
              case METRIC.reps: newSet.targetReps = value; break;
              case METRIC.weight: newSet.targetWeight = value; break;
              case METRIC.duration: newSet.targetDuration = value; break;
              case METRIC.distance: newSet.targetDistance = value; break;
              case METRIC.rest: newSet.targetRest = value; break;
              case METRIC.tempo: newSet.targetTempo = value; break;
            }

            // Ensure metric is in fieldOrder
            if (!newSet.fieldOrder) newSet.fieldOrder = [];
            if (!newSet.fieldOrder.includes(metric)) newSet.fieldOrder.push(metric);
          });

          return newSet;
        });

        return { ...exercise, sets: newSets };
      });

      return { ...r, exercises: newExercises };
    });

    // 5. Update performanceInputValues for all sets in all target exercises
    targetExercises.forEach(exercise => {
      exercise.sets.forEach((set) => {
        metricsToApply.forEach(({ metric, value }) => {
          this.setPerformanceInputValue(exercise.id, set.id, metric, value);
        });
      });
    });

    // 6. Update logged sets in the workout log
    this.currentWorkoutLog.update(log => {
      if (!log.exercises) return log;

      targetExercises.forEach(exercise => {
        const loggedEx = log.exercises?.find(le => le.id === exercise.id);
        if (!loggedEx) return;

        loggedEx.sets.forEach(loggedSet => {
          metricsToApply.forEach(({ metric, value }) => {
            switch (metric) {
              case METRIC.reps:
                loggedSet.targetReps = value;
                loggedSet.repsLogged = value;
                break;
              case METRIC.weight:
                loggedSet.targetWeight = value;
                loggedSet.weightLogged = value;
                break;
              case METRIC.duration:
                loggedSet.targetDuration = value;
                loggedSet.durationLogged = value;
                break;
              case METRIC.distance:
                loggedSet.targetDistance = value;
                loggedSet.distanceLogged = value;
                break;
              case METRIC.rest:
                loggedSet.targetRest = value;
                loggedSet.restLogged = value;
                break;
              case METRIC.tempo:
                loggedSet.targetTempo = value;
                loggedSet.tempoLogged = value;
                break;
            }

            // Ensure metric is in fieldOrder
            if (!loggedSet.fieldOrder) loggedSet.fieldOrder = [];
            if (!loggedSet.fieldOrder.includes(metric)) loggedSet.fieldOrder.push(metric);
          });
        });
      });

      return { ...log };
    });

    // 7. Reset UI and provide feedback
    this.repsToSetForAll.set(null);
    this.weightToSetForAll.set(null);
    this.durationToSetForAll.set(null);
    this.distanceToSetForAll.set(null);
    this.restToSetForAll.set(null);
    this.tempoToSetForAll.set(null);
    this.expandedSetAllPanel.set(null);

    // Build a summary of what was set
    const summaryParts: string[] = [];
    if (reps !== null) summaryParts.push(`${this.translate.instant('metrics.reps')}: ${reps}`);
    if (weight !== null) summaryParts.push(`${this.translate.instant('metrics.weight')}: ${weight} (${this.unitsService.getWeightUnitSuffix()})`);
    if (duration !== null) summaryParts.push(`${this.translate.instant('metrics.duration')}: ${duration} (s)`);
    if (distance !== null) summaryParts.push(`${this.translate.instant('metrics.distance')}: ${distance} (${this.unitsService.getDistanceUnitSuffix()})`);
    if (rest !== null) summaryParts.push(`${this.translate.instant('metrics.rest')}: ${rest} (s)`);
    if (tempo !== null) summaryParts.push(`${this.translate.instant('metrics.tempo')}: ${tempo}`);

    const summary = summaryParts.length > 0
      ? summaryParts.join(', ')
      : this.translate.instant('compactPlayer.set.none');

    this.toastService.success(
      this.translate.instant('compactPlayer.set.metricsUpdatedCount', {
        summary,
        count: updatedSetsCount
      }),
      5000
    );
  }

  toggleMetricForAllSets(exerciseId: string, metric: METRIC): void {
    const routine = this.routine();
    if (!routine) return;

    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return;

    // Check if this exercise is part of a group block (superset/circuit/EMOM)
    const isSuperset = this.isExerciseInGroupBlock(exerciseId);

    // If in a group block, apply to all exercises in the group; else just this one
    const exercisesToUpdate = isSuperset
      ? this.getSupersetExercises(exerciseId)
      : [exercise];

    let affectedSetsCount = 0;

    // Determine shouldAdd ONCE based on the first set of the first exercise
    let shouldAdd = false;
    if (exercisesToUpdate.length > 0 && exercisesToUpdate[0].sets.length > 0) {
      shouldAdd = !exercisesToUpdate[0].sets[0].fieldOrder?.includes(metric);
    }

    // Only consider metrics except rest for blocking logic
    const metricsToCheck = this.availableMetricsForSetAll.filter(m => m !== METRIC.rest);

    // If removing, check if this would remove all non-rest metrics
    if (!shouldAdd && metricsToCheck.some(m => m === metric)) {
      const currentActive = metricsToCheck.filter(m =>
        m !== metric && exercise.sets.some(set => set.fieldOrder?.includes(m))
      );
      if (currentActive.length === 0) {
        this.toastService.error(
          this.translate.instant('compactPlayer.set.atLeastOneMetric'),
          2500
        );
        return;
      }
    }

    // Update the routine first
    this.routine.update(r => {
      if (!r) return r;

      const newExercises = r.exercises.map(ex => {
        // Only update exercises that are in our target list
        if (!exercisesToUpdate.some(target => target.id === ex.id)) {
          return ex;
        }

        const newSets = ex.sets.map((set) => {
          const newSet = { ...set };
          if (!newSet.fieldOrder) newSet.fieldOrder = [];

          const hasMetric = newSet.fieldOrder.includes(metric);

          if (shouldAdd) {
            // Special handling for rest metric in group blocks
            if (metric === METRIC.rest && isSuperset) {
              // For standard supersets/circuits: only add rest to the last exercise
              if (!this.isEmom(exerciseId)) {
                const exercisesInBlock = this.getSupersetExercises(exerciseId);
                const isLastExercise = ex.id === exercisesInBlock[exercisesInBlock.length - 1].id;
                if (!isLastExercise) {
                  return newSet; // Skip non-last exercises
                }
              } else {
                // For EMOM: don't add rest at all
                return newSet;
              }
            }

            if (!hasMetric) {
              newSet.fieldOrder.push(metric);
              affectedSetsCount++;

              // Set default value if not present
              switch (metric) {
                case METRIC.rest:
                  if (!newSet.targetRest) newSet.targetRest = restToExact(60);
                  this.setPerformanceInputValue(ex.id, newSet.id, metric, newSet.targetRest);
                  break;
                case METRIC.weight:
                  if (!newSet.targetWeight) newSet.targetWeight = weightToExact(10);
                  this.setPerformanceInputValue(ex.id, newSet.id, metric, newSet.targetWeight);
                  break;
                case METRIC.reps:
                  if (!newSet.targetReps) newSet.targetReps = repsToExact(8);
                  this.setPerformanceInputValue(ex.id, newSet.id, metric, newSet.targetReps);
                  break;
                case METRIC.distance:
                  if (!newSet.targetDistance) newSet.targetDistance = distanceToExact(2);
                  this.setPerformanceInputValue(ex.id, newSet.id, metric, newSet.targetDistance);
                  break;
                case METRIC.duration:
                  if (!newSet.targetDuration) newSet.targetDuration = durationToExact(45);
                  this.setPerformanceInputValue(ex.id, newSet.id, metric, newSet.targetDuration);
                  break;
              }
            }
          } else {
            // Remove metric
            if (hasMetric) {
              newSet.fieldOrder = newSet.fieldOrder.filter(m => m !== metric);
              affectedSetsCount++;

              // Remove the target property
              switch (metric) {
                case METRIC.rest:
                  newSet.targetRest = undefined;
                  const restKey = this.getSetKey(ex.id, newSet.id);
                  this.restStartTimestamps[restKey] = 0;
                  break;
                case METRIC.weight:
                  newSet.targetWeight = undefined;
                  break;
                case METRIC.reps:
                  newSet.targetReps = undefined;
                  break;
                case METRIC.distance:
                  newSet.targetDistance = undefined;
                  break;
                case METRIC.duration:
                  newSet.targetDuration = undefined;
                  break;
              }

              // Remove from performanceInputValues
              this.performanceInputValues.update(inputs => {
                const key = this.getSetKey(ex.id, newSet.id);
                if (inputs[key]) {
                  delete inputs[key][this.getFieldKey(metric)];
                }
                return { ...inputs };
              });
            }
          }

          return newSet;
        });

        return { ...ex, sets: newSets };
      });

      return { ...r, exercises: newExercises };
    });

    // Update logged sets in the workout log for all affected exercises
    this.currentWorkoutLog.update(log => {
      if (!log.exercises) return log;

      exercisesToUpdate.forEach(targetEx => {
        const loggedEx = log.exercises?.find(le => le.id === targetEx.id);
        if (!loggedEx) return;

        loggedEx.sets.forEach((loggedSet, setIndex) => {
          const plannedSet = targetEx.sets[setIndex];
          if (!plannedSet) return;

          if (shouldAdd) {
            if (!loggedSet.fieldOrder) loggedSet.fieldOrder = [];
            if (!loggedSet.fieldOrder.includes(metric)) {
              loggedSet.fieldOrder.push(metric);

              switch (metric) {
                case METRIC.rest:
                  loggedSet.targetRest = plannedSet.targetRest ?? restToExact(60);
                  loggedSet.restLogged = plannedSet.targetRest ?? restToExact(60);
                  break;
                case METRIC.weight:
                  loggedSet.targetWeight = plannedSet.targetWeight ?? weightToExact(10);
                  loggedSet.weightLogged = plannedSet.targetWeight ?? weightToExact(10);
                  break;
                case METRIC.reps:
                  loggedSet.targetReps = plannedSet.targetReps ?? repsToExact(8);
                  loggedSet.repsLogged = plannedSet.targetReps ?? repsToExact(8);
                  break;
                case METRIC.distance:
                  loggedSet.targetDistance = plannedSet.targetDistance ?? distanceToExact(2);
                  loggedSet.distanceLogged = plannedSet.targetDistance ?? distanceToExact(2);
                  break;
                case METRIC.duration:
                  loggedSet.targetDuration = plannedSet.targetDuration ?? durationToExact(45);
                  loggedSet.durationLogged = plannedSet.targetDuration ?? durationToExact(45);
                  break;
              }
            }
          } else {
            // Remove metric
            if (loggedSet.fieldOrder) {
              loggedSet.fieldOrder = loggedSet.fieldOrder.filter(m => m !== metric);
            }

            switch (metric) {
              case METRIC.rest:
                loggedSet.targetRest = undefined;
                loggedSet.restLogged = undefined;
                break;
              case METRIC.weight:
                loggedSet.targetWeight = undefined;
                loggedSet.weightLogged = undefined;
                break;
              case METRIC.reps:
                loggedSet.targetReps = undefined;
                loggedSet.repsLogged = undefined;
                break;
              case METRIC.distance:
                loggedSet.targetDistance = undefined;
                loggedSet.distanceLogged = undefined;
                break;
              case METRIC.duration:
                loggedSet.targetDuration = undefined;
                loggedSet.durationLogged = undefined;
                break;
            }
          }
        });
      });

      return { ...log };
    });

    // Sync blocks after modification
    const updatedRoutine = this.routine();
    if (updatedRoutine) {
      this.syncRoutineBlocksAfterModification(updatedRoutine);
    }

    // Show feedback toast with count
    if (shouldAdd) {
      this.toastService.success(
        this.translate.instant('compactPlayer.set.metricAddedCount', {
          metric: this.translate.instant('metrics.' + metric),
          count: affectedSetsCount
        }),
        2500
      );
    } else {
      this.toastService.info(
        this.translate.instant('compactPlayer.set.metricRemovedCount', {
          metric: this.translate.instant('metrics.' + metric),
          count: affectedSetsCount
        }),
        2500
      );
    }
  }

  isTextReps(exerciseId: string, setId: string): boolean {
    const routine = this.routine();
    if (!routine) return false;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return false;
    const set = exercise.sets.find(s => s.id === setId);

    const repType = set?.targetReps?.type;

    if (!repType) {
      return false;
    }

    // The input should be 'text' for ANY scheme that isn't a simple, exact number.
    // This correctly includes 'range', 'min_plus', 'amrap', and 'max'.
    return repType !== RepsTargetType.exact;
  }

  isTextWeight(exerciseId: string, setId: string): boolean {
    const routine = this.routine();
    if (!routine) return false;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return false;
    const set = exercise.sets.find(s => s.id === setId);
    const weightType = set?.targetWeight?.type;

    if (!weightType) {
      return false;
    }
    return weightType !== WeightTargetType.exact;
  }

  /**
    * Checks if any input field for a given set is currently marked as invalid.
    * @param exerciseId The id of the exercise.
    * @param setId The id of the set.
    * @returns True if at least one field for the set has a validation error.
    */
  protected hasInvalidInput(exerciseId: string, setId: string, metric?: METRIC): boolean {
    const prefix = this.getSetKey(exerciseId, setId);
    // Convert the Set to an array and check if any key starts with the set's prefix.
    if (metric) {
      return Array.from(this.invalidInputs()).some(key => key.startsWith(prefix) && key.includes(metric.toString()));
    }
    return Array.from(this.invalidInputs()).some(key => key.startsWith(prefix));
  }

  protected countAvailableMetrics(exerciseId: string, setId: string, metric: METRIC): number {
    const routine = this.routine();
    if (!routine) return 0;
    const set = this.getWorkoutExerciseById(routine, exerciseId)?.sets.find(s => s.id === setId);
    if (!set) return 0;

    let availableSchemes: AnyScheme[];
    let currentTarget: AnyTarget | null | undefined;

    // 1. Get the correct metadata array and current value based on the metric.
    //    CRUCIALLY, we filter for `availableInPlayer` because this is the player component.
    switch (metric) {
      case METRIC.reps:
        availableSchemes = REPS_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetReps;
        break;
      case METRIC.weight:
        availableSchemes = WEIGHT_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetWeight;
        break;
      case METRIC.duration:
        availableSchemes = DURATION_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetDuration;
        break;
      case METRIC.distance:
        availableSchemes = DISTANCE_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetDistance;
        break;
      case METRIC.rest:
        availableSchemes = REST_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetRest;
        break;
      default:
        this.toastService.error(`Scheme editing is not supported for metric: ${metric}`);
        return 0;
    }


    availableSchemes = availableSchemes.filter(s => s.type !== currentTarget?.type);

    return availableSchemes.length;
  }

  /**
 * GENERIC: Opens a modal to configure the target scheme for any metric.
 * @param exerciseId The id of the exercise.
 * @param setId The id   of the set.
 * @param metric The metric to be configured (e.g., 'reps', 'weight').
 * @param event The mouse event to stop propagation.
 */
  async openMetricSchemeModal(exerciseId: string, setId: string, metric: METRIC, event?: Event): Promise<void> {
    event?.stopPropagation();

    const routine = this.routine();
    if (!routine) return;
    const set = this.getWorkoutExerciseById(routine, exerciseId)?.sets.find(s => s.id === setId);
    if (!set) return;

    let availableSchemes: AnyScheme[];
    let currentTarget: AnyTarget | null | undefined;

    // 1. Get the correct metadata array and current value based on the metric.
    //    CRUCIALLY, we filter for `availableInPlayer` because this is the player component.
    switch (metric) {
      case METRIC.reps:
        availableSchemes = REPS_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetReps;
        break;
      case METRIC.weight:
        availableSchemes = WEIGHT_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetWeight;
        break;
      case METRIC.duration:
        availableSchemes = DURATION_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetDuration;
        break;
      case METRIC.distance:
        availableSchemes = DISTANCE_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetDistance;
        break;
      case METRIC.rest:
        availableSchemes = REST_TARGET_SCHEMES.filter(s => s.availableInPlayer);
        currentTarget = set.targetRest;
        break;
      default:
        this.toastService.error(`Scheme editing is not supported for metric: ${metric}`);
        return;
    }

    // remove from the availableSchemes the current one
    availableSchemes = availableSchemes.filter(s => s.type !== currentTarget?.type);
    if (availableSchemes.length === 0) {
      this.toastService.info(
        this.translate.instant('compactPlayer.toasts.noFurtherSchemes', { metric: this.translate.instant('metrics.' + metric).toUpperCase() }),
        8000,
        this.translate.instant('common.info')
      );
      return;
    }

    // 2. Call the generic service method.
    const result = await this.workoutUtilsService.showSchemeModal(
      metric,
      currentTarget ?? null, // This ensures we only pass AnyTarget or null
      availableSchemes
    );

    // 3. If a new target is returned, update the routine state.
    if (result && result.data) {
      this.updateSetMetricTarget(exerciseId, setId, metric, result.data);
      this._prefillPerformanceInputs(true); // Resync performance inputs with the new plan
      this.scrollToSet(exerciseId, setId);
    }
  }

  /**
     * GENERIC: Updates a specific metric's target object for a given set within the routine.
     * @param exerciseId The id of the exercise.
     * @param setId The id of the set.
     * @param metric The metric to update.
     * @param newTarget The new target object.
     */
  updateSetMetricTarget(exerciseId: string, setId: string, metric: METRIC, newTarget: AnyTarget): void {
    this.routine.update(routine => {
      if (!routine) return routine;

      const set = this.getWorkoutExerciseById(routine, exerciseId)?.sets.find(s => s.id === setId);
      if (set) {
        // Use a switch to assign the new target object to the correct property.
        switch (metric) {
          case METRIC.reps:
            set.targetReps = newTarget as RepsTarget;
            break;
          case METRIC.weight:
            set.targetWeight = newTarget as WeightTarget;
            break;
          case METRIC.duration:
            set.targetDuration = newTarget as DurationTarget;
            break;
          case METRIC.distance:
            set.targetDistance = newTarget as DistanceTarget;
            break;
          case METRIC.rest:
            set.targetRest = newTarget as RestTarget;
            break;
        }
        // Show a generic success message.
        this.toastService.info(`Set ${setId} ${metric} target changed.`);
      }

      return { ...routine };
    });
  }


  getDurationValue(duration: DurationTarget | undefined): number {
    return getDurationValue(duration);
  }

  getWeightValue(weight: WeightTarget | undefined): number {
    return getWeightValue(weight);
  }

  getDistanceValue(distance: DistanceTarget | undefined): number {
    return getDistanceValue(distance);
  }

  getRestValue(rest: RestTarget | undefined): number {
    return getRestValue(rest);
  }

  getRepsValue(reps: RepsTarget | undefined): number {
    return repsTypeToReps(reps);
  }


  readonly allAvailableMetrics: METRIC[] = [
    METRIC.reps,
    METRIC.weight,
    METRIC.distance,
    METRIC.duration,
    METRIC.rest
  ];

  get availableMetricsForSetAll(): METRIC[] {
    return this.allAvailableMetrics;
  }

  /**
 * Returns the available metrics for a set.
 * - For supersets: only weight, reps, and rest are allowed.
 * - For standard exercises: all metrics are allowed.
 */
  getAvailableMetricsForSet(exerciseId: string): METRIC[] {
    const routine = this.routine();
    if (!routine) return [];
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return [];

    if (this.isExerciseInGroupBlock(exerciseId)) {
      if (this.isEmom(exerciseId)) {
        return [METRIC.weight, METRIC.reps];
      }
      // Only allow weight, reps, and rest for supersets
      return [METRIC.weight, METRIC.reps, METRIC.rest];
    } else {
      // Allow all metrics for standard exercises
      return [
        METRIC.reps,
        METRIC.weight,
        METRIC.distance,
        METRIC.duration,
        METRIC.rest
      ];
    }
  }




  protected repsStep: number = 1;
  protected weightStep: number = 0.1;
  protected durationStep: number = 5;
  protected distanceStep: number = 0.1;
  protected restStep: number = 5;

  // Add this property to your component
  activeSetAllMetrics: { [exerciseId: string]: METRIC[] } = {};
  isMetricActiveForAllSets(exerciseId: string, metric: METRIC): boolean {
    const routine = this.routine();
    if (!routine) return false;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return false;
    // The chip is active only if ALL sets have the metric in their fieldOrder
    return exercise.sets.every(set => set.fieldOrder?.includes(metric));
  }

  protected getSet(exerciseId: string, setId: string) {
    const routine = this.routine();
    if (!routine) return undefined;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return undefined;
    // Try to find by set id first, then by index if not found
    let set = exercise.sets.find(s => s.id === setId);
    // Optionally, you could try to find by index if setId is a number (uncomment if needed)
    // if (!set && typeof setId === 'number') {
    //   set = exercise.sets[setId];
    // }
    return set;
  }


  getPerformanceInputValue(exerciseId: string, setId: string, field: METRIC | 'notes'): any {
    const key = this.getSetKey(exerciseId, setId);
    const set = this.getSet(exerciseId, setId);
    if (!set?.fieldOrder?.includes(field as METRIC) && field !== 'notes') return undefined;
    return this.performanceInputValues()[key]?.[this.getFieldKey(field)];
  }

  onInputChange(value: any, exerciseId: string, setId: string, field: METRIC | 'notes') {
    this.setPerformanceInputValue(exerciseId, setId, field, value);
    // Optionally: run validation or other logic here
  }

  setPerformanceInputValue(exerciseId: string, setId: string, field: METRIC | 'notes', value: any): void {
    const key = this.getSetKey(exerciseId, setId);
    const set = this.getSet(exerciseId, setId);
    if (!set?.fieldOrder?.includes(field as METRIC) && field !== 'notes') return;

    this.performanceInputValues.update(inputs => {
      const updated = { ...inputs };
      if (!updated[key]) updated[key] = {};
      updated[key][this.getFieldKey(field)] = value;
      return updated;
    });
  }



  getFieldKey(field: METRIC | 'notes'): keyof ExerciseCurrentExecutionSetParams {
    switch (field) {
      case METRIC.reps: return 'actualReps';
      case METRIC.weight: return 'actualWeight';
      case METRIC.distance: return 'actualDistance';
      case METRIC.duration: return 'actualDuration';
      case METRIC.rest: return 'actualRest';
      case METRIC.tempo: return 'tempoLogged';
      case 'notes': return 'notes';
    }
  }

  getMetricInputValue(): any {
    return (exerciseId: string, setId: string, field: METRIC | 'notes') => {
      const key = this.getSetKey(exerciseId, setId);
      const value = this.performanceInputValues()[key]?.[this.getFieldKey(field)];
      switch (field) {
        case METRIC.reps:
          return value && typeof value === 'object' && 'type' in value
            ? repsTargetAsString(value as RepsTarget)
            : value ?? '';
        case METRIC.weight:
          return value && typeof value === 'object' && 'type' in value
            ? weightTargetAsString(value as WeightTarget)
            : value ?? '';
        case METRIC.distance:
          return value && typeof value === 'object' && 'type' in value
            ? distanceTargetAsString(value as DistanceTarget)
            : value ?? '';
        case METRIC.duration:
          return value && typeof value === 'object' && 'type' in value
            ? durationTargetAsString(value as DurationTarget)
            : value ?? '';
        case METRIC.rest:
          return value && typeof value === 'object' && 'type' in value
            ? restTargetAsString(value as RestTarget)
            : value ?? '';
        case METRIC.tempo:
          return value ?? '';
        case 'notes':
          return value ?? '';
      }
      return '';
    };
  }

  setMetricInputValue(exerciseId: string, setId: string, field: METRIC | 'notes', value: any): void {
    const key = this.getSetKey(exerciseId, setId);
    const inputKey = `${key}-${field}`;
    const set = this.getSet(exerciseId, setId);
    if (!set?.fieldOrder?.includes(field as METRIC) && field !== 'notes') return;

    this.performanceInputValues.update(inputs => {
      const updated = { ...inputs };
      if (!updated[key]) updated[key] = {};

      // Validation logic (adapted from updateSetData)
      switch (field) {
        case METRIC.reps: {
          const rawValue = String(value).trim();
          const validRepsPattern = /^(\d+(\+)?|AMRAP|MAX)$/i;

          if (rawValue === '' || validRepsPattern.test(rawValue)) {
            this.invalidInputs.update(s => { s.delete(inputKey); return s; });

            if (rawValue.endsWith('+')) {
              const numericValue = parseInt(rawValue.slice(0, -1), 10);
              updated[key].actualReps = { type: RepsTargetType.min_plus, value: numericValue };
            } else if (rawValue.toUpperCase() === 'AMRAP') {
              updated[key].actualReps = { type: RepsTargetType.amrap };
            } else if (rawValue.toUpperCase() === 'MAX') {
              updated[key].actualReps = { type: RepsTargetType.max };
            } else {
              const numericValue = parseInt(rawValue, 10);
              if (!isNaN(numericValue)) {
                updated[key].actualReps = { type: RepsTargetType.exact, value: numericValue };
              } else {
                updated[key].actualReps = undefined;
                this.invalidInputs.update(s => { s.add(inputKey); return s; });
              }
            }
          } else {
            this.invalidInputs.update(s => { s.add(inputKey); return s; });
          }
          break;
        }
        case METRIC.weight: {
          const rawWeight = String(value).trim();
          const validWeightPattern = /^(\d+(\.\d+)?|MAX|RM|BW|AMRAP)$/i;

          if (rawWeight === '' || validWeightPattern.test(rawWeight)) {
            this.invalidInputs.update(s => { s.delete(inputKey); return s; });

            if (rawWeight.toUpperCase().includes('%')) {
              updated[key].actualWeight = { type: WeightTargetType.percentage_1rm, percentage: 100 };
            } else if (rawWeight.toUpperCase() === 'BW') {
              updated[key].actualWeight = { type: WeightTargetType.bodyweight };
            } else {
              const numericValue = parseFloat(rawWeight);
              if (!isNaN(numericValue)) {
                updated[key].actualWeight = { type: WeightTargetType.exact, value: numericValue };
              } else {
                updated[key].actualWeight = undefined;
                this.invalidInputs.update(s => { s.add(inputKey); return s; });
              }
            }
          } else {
            this.invalidInputs.update(s => { s.add(inputKey); return s; });
          }
          break;
        }
        case METRIC.distance:
          updated[key].actualDistance = distanceToExact(parseFloat(value)) || undefined;
          break;
        case METRIC.duration:
          updated[key].actualDuration = durationToExact(this.parseTimeToSeconds(value));
          break;
        case METRIC.rest:
          updated[key].actualRest = restToExact(this.parseTimeToSeconds(value));
          break;
        case METRIC.tempo:
          updated[key].tempoLogged = value === '' ? undefined : value;
          break;
        case 'notes':
          updated[key].notes = value;
          break;
      }
      return updated;
    });
  }

  showExerciseSelectionModal = signal(false);
  async onAddExercisesSelected(exercises: Exercise[]) {
    this.showExerciseSelectionModal.set(false);

    for (const exercise of exercises) {
      // Use the same logic as selectExerciseToAddFromModal
      const log = this.currentWorkoutLog();
      const allLoggedExercises = log.exercises || [];
      const lastLoggedExercise = allLoggedExercises.length > 0 ? allLoggedExercises[allLoggedExercises.length - 1] : null;
      const lastLoggedSet = lastLoggedExercise && lastLoggedExercise.sets.length > 0 ? lastLoggedExercise.sets[lastLoggedExercise.sets.length - 1] : null;

      const newWorkoutExercise = await this.workoutService.promptAndCreateWorkoutExercise(exercise, lastLoggedSet);

      if (newWorkoutExercise) {
        if (exercise.id.startsWith('custom-adhoc-ex-')) {
          const newExerciseToBeSaved = this.exerciseService.mapWorkoutExerciseToExercise(newWorkoutExercise, exercise);
          this.exerciseService.addExercise(newExerciseToBeSaved);
        }
        this.addExerciseToRoutine(newWorkoutExercise);
      }
    }
  }

  getSectionForExercise(exerciseId: string): WorkoutSection | null {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise || !exercise.section) return null;
    return this.routine()?.sections?.find(s => s.type === exercise.section) ?? null;
  }


  // Add this with your other signals
  expandedMetricsSection = signal<string | null>(null); // Key will be "exIndex-setIndex"
  toggleMetricsSection(exerciseId: string, setId: string, event?: Event): void {
    event?.stopPropagation();
    const key = this.getSetKey(exerciseId, setId);
    const isSetExpanded = this.expandedSets().has(key);
    const isMetricsExpanded = this.expandedMetricsSection() === key;

    if (!isMetricsExpanded) {
      // If metrics section is not expanded, expand it and ensure set is expanded
      this.expandedMetricsSection.set(key);
      if (!isSetExpanded) {
        this.expandedSets.update(currentSet => {
          const newSet = new Set(currentSet);
          newSet.add(key);
          return newSet;
        });
      }
    } else {
      // If metrics section is expanded, collapse it and also collapse set
      this.expandedMetricsSection.set(null);
      if (isSetExpanded) {
        this.expandedSets.update(currentSet => {
          const newSet = new Set(currentSet);
          newSet.delete(key);
          return newSet;
        });
      }
    }
  }

  isMetricsSectionExpanded(exerciseId: string, setId: string): boolean {
    const key = this.getSetKey(exerciseId, setId);
    return this.expandedMetricsSection() === key;
  }


  setActionItemsMap = computed<Map<string, ActionMenuItem[]>>(() => {
    const map = new Map<string, ActionMenuItem[]>();
    const routine = this.routine();
    const commonModalButtonClass = this.menuButtonBaseClass();

    if (!routine) return map;

    routine.exercises.forEach((exercise) => {
      exercise.sets.forEach((set, setIndex) => {
        const key = this.getSetKey(exercise.id, set.id);
        const isCompleted = this.isSetCompleted(exercise.id, set.id);

        const items: ActionMenuItem[] = [];

        if (!isCompleted) {
          // Toggle Metrics Button
          if (!this.isExerciseInGroupBlock(exercise.id)) {
            items.push({
              ...metricsBtn,
              label: this.translate.instant('compactPlayer.toggleMetrics'),
              data: { exerciseId: exercise.id, setId: set.id }
            });
          }


          // Rest Button
          items.push({
            ...restBtn,
            data: { exerciseId: exercise.id, setId: set.id },
            label: this.translate.instant('compactPlayer.rest'),
          });
        }

        // Notes Button
        items.push({
          ...setNotesBtn,
          label: this.translate.instant('compactPlayer.setNotes'),
          data: { exerciseId: exercise.id, setId: set.id }
        });

        // Remove Set Button
        items.push({
          ...removeSetFromExerciseBtn,
          label: this.isExerciseInGroupBlock(exercise.id) ? this.translate.instant('actionButtons.removeRound') : this.translate.instant('actionButtons.removeSet'),
          data: { exerciseId: exercise.id, setId: set.id }
        });

        map.set(key, items);
      });
    });

    return map;
  });

  activeSetActionMenuKey = signal<string | null>(null);

  handleSetActionMenuItemClick(event: { actionKey: string, data?: any }): void {
    const { actionKey, data } = event;
    const { exIndex, setIndex } = data;

    switch (actionKey) {
      case 'toggle_metrics':
        this.toggleMetricsSection(exIndex, setIndex, new Event('click'));
        break;
      case 'set_notes':
        this.toggleSetNotes(exIndex, setIndex, new Event('click'));
        break;
      case 'rest':
        this.openRestModal(exIndex, setIndex, new Event('click'));
        break;
      case 'removeSet':
        this.removeSet(exIndex, setIndex);
        break;
    }

    this.closeSetActionMenu();
  }

  toggleSetActionMenu(exerciseId: string, setId: string, event: Event): void {
    event.stopPropagation();
    const key = this.getSetKey(exerciseId, setId);
    this.activeSetActionMenuKey.update(current => current === key ? null : key);
    this.closeExerciseActionMenu();
    this.closeMainSessionActionMenu();
  }

  closeSetActionMenu() {
    this.activeSetActionMenuKey.set(null);
  }

  /**
 * Checks if a metric input field should be disabled.
 * Duration fields are disabled when their associated timer (set timer or EMOM) is running.
 * @param exIndex The exercise index
 * @param setIndex The set/round index
 * @param field The metric field to check
 * @returns True if the field should be disabled
 */
  isMetricInputDisabled(exerciseId: string, setId: string, field: METRIC): boolean {
    if (field !== METRIC.duration) {
      return false;
    }

    const setTimerRunning = this.getSetTimerState(exerciseId, setId).status === this.timerSetEnum.Running;
    const emomTimerRunning = this.getEmomState(exerciseId, setId).status === this.timerSetEnum.Running;

    return setTimerRunning || emomTimerRunning;
  }


  protected getSetTimerProgress(exerciseId: string, setId: string): number {
    const set = this.getWorkoutExerciseById(this.routine(), exerciseId)?.sets.find(s => s.id === setId);
    if (!set) return 0;

    const performanceKey = this.getSetKey(exerciseId, setId);
    const actualDuration = getDurationValue(this.performanceInputValues()[performanceKey]?.actualDuration);
    const targetDuration = getDurationValue(set.targetDuration);
    const totalDuration = actualDuration ?? targetDuration ?? 1;

    const elapsed = totalDuration - this.getSetTimerState(exerciseId, setId).remainingTime;
    const progress = (elapsed / totalDuration) * 100;

    return Math.min(100, Math.max(0, progress)); // Clamp between 0 and 100
  }


  // Modal state and context
  noteModalVisible = signal(false);
  noteModalContext = signal<{ type: 'session' | 'exercise' | 'set', exerciseId?: string, setId?: string } | null>(null);
  noteModalValue = signal<string>('');
  openNoteModal(type: 'session' | 'exercise' | 'set', exerciseId?: string, setId?: string) {
    let initial = '';
    if (type === 'session') {
      initial = this.currentWorkoutLog().notes ?? '';
    } else if (type === 'exercise' && exerciseId !== undefined) {
      initial = this.getWorkoutExerciseById(this.routine(), exerciseId)?.notes ?? '';
    } else if (type === 'set' && exerciseId !== undefined && setId !== undefined) {
      const key = this.getSetKey(exerciseId, setId);
      // Prefer logged set, then user input, then planned
      const loggedSet = this.getLoggedSet(exerciseId, setId);
      initial = loggedSet?.notes
        ?? this.performanceInputValues()[key]?.notes
        ?? this.getWorkoutExerciseById(this.routine(), exerciseId)?.sets.find(s => s.id === setId)?.notes
        ?? '';
    }
    this.noteModalContext.set({ type, exerciseId, setId });
    this.noteModalValue.set(initial);
    this.noteModalVisible.set(true);
  }

  async saveNoteModal() {
    const ctx = this.noteModalContext();
    const value = this.noteModalValue();
    if (!ctx) return;

    if (ctx.type === 'session') {
      this.currentWorkoutLog.update(log => {
        log.notes = value;
        return { ...log };
      });
      this.toastService.success(this.translate.instant('compactPlayer.toasts.sessionNotesUpdated'));
    } else if (ctx.type === 'exercise' && ctx.exerciseId !== undefined && typeof ctx.exerciseId === 'string') {
      const exerciseId = ctx.exerciseId;
      this.routine.update(r => {
        if (!r) return r;
        r.exercises.find(ex => ex.id === exerciseId)!.notes = value;
        return { ...r };
      });
      // Also update log if exercise is logged
      const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
      if (exercise) {
        this.currentWorkoutLog.update(log => {
          const loggedEx = log.exercises?.find(ex => ex.id === exercise.id);
          if (loggedEx) loggedEx.notes = value;
          return { ...log };
        });
      }
      this.toastService.success(this.translate.instant('compactPlayer.toasts.exerciseNotesUpdated'));
    } else if (
      ctx.type === 'set' &&
      typeof ctx.exerciseId === 'string' &&
      typeof ctx.setId === 'string'
    ) {
      const key = `${ctx.exerciseId}-${ctx.setId}`;
      this.performanceInputValues.update(inputs => {
        if (!inputs[key]) inputs[key] = {};
        inputs[key].notes = value;
        return { ...inputs };
      });
      // If set is logged, update log as well
      const exercise = this.getWorkoutExerciseById(this.routine(), ctx.exerciseId);
      if (exercise) {
        const exerciseId = ctx.exerciseId;
        this.currentWorkoutLog.update(log => {
          const loggedEx = log.exercises?.find(ex => ex.id === exercise.id);
          if (loggedEx) {
            const loggedSet = loggedEx.sets.find(s => s.plannedSetId === ctx.setId);
            if (loggedSet) loggedSet.notes = value;
          }
          return { ...log };
        });
      }
      this.toastService.success(this.translate.instant('compactPlayer.toasts.setNotesUpdated'));
    }
    this.closeNoteModal();
  }

  closeNoteModal() {
    this.noteModalVisible.set(false);
    this.noteModalContext.set(null);
    this.noteModalValue.set('');
  }


  getNoteModalTitle(): string {
    const ctx = this.noteModalContext();
    if (!ctx) return '';

    if (ctx.type === 'session') {
      return this.translate.instant('compactPlayer.sessionNotes');
    }

    if (ctx.type === 'exercise' && typeof ctx.exerciseId === 'string') {
      const exercise = this.getWorkoutExerciseById(this.routine(), ctx.exerciseId);
      if (exercise) {
        return `${this.translate.instant('compactPlayer.exerciseNotes')} - ${exercise.exerciseName || ''}`;
      }
      return this.translate.instant('compactPlayer.exerciseNotes');
    }

    if (ctx.type === 'set' && typeof ctx.exerciseId === 'string' && typeof ctx.setId === 'string') {
      const exercise = this.getWorkoutExerciseById(this.routine(), ctx.exerciseId);
      const setNumber = (exercise?.sets?.findIndex(set => set.id === ctx.setId) ?? -1) + 1 || 1;
      if (exercise) {
        return `${this.translate.instant('compactPlayer.setNotes')} - ${exercise.exerciseName || ''} (Set ${setNumber})`;
      }
      return `${this.translate.instant('compactPlayer.setNotes')} (Set ${setNumber})`;
    }

    return '';
  }

  getWeightTargetType(weightTarget?: WeightTarget): WeightTargetType | undefined {
    if (!weightTarget) {
      return undefined;
    }
    return weightTarget.type;
  }

  getSetUniformValues(exerciseId: string, setId: string) {
    const routine = this.routine();
    if (!routine) return {};
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return {};

    const plannedSet = exercise.sets.find(s => s.id === setId);
    if (!plannedSet) return {};
    const loggedSet = this.getLoggedSet(exercise.id, plannedSet.id);
    const key = this.getSetKey(exercise.id, plannedSet.id);
    const userInputs = this.performanceInputValues()[key] || {};

    let weightIcon = 'body';
    let weightValue = this.workoutUtilsService.weightTargetAsString(
      userInputs.actualWeight ??
      loggedSet?.weightLogged ??
      plannedSet.targetWeight
    );
    const weightTargetType = this.getWeightTargetType(
      userInputs.actualWeight ??
      loggedSet?.weightLogged ??
      plannedSet.targetWeight
    );
    switch (weightTargetType) {
      case WeightTargetType.exact:
      case WeightTargetType.range:
      case WeightTargetType.percentage_1rm:
        weightIcon = 'weight';
        break;
      case WeightTargetType.bodyweight: {
        break;
      }
    }


    // if it's castable to a number return it with the unitsService.suffix, otherwise return it as it is
    if (!isNaN(Number(weightValue)) && weightValue !== '') {
      weightValue = `${weightValue} ${this.unitsService.getWeightUnitSuffix()}`;
      weightIcon = 'weight';
    }

    return {
      reps: this.workoutUtilsService.repsTargetAsString(
        userInputs.actualReps ??
        loggedSet?.repsLogged ??
        plannedSet.targetReps
      ),
      weight: weightValue,
      distance: this.getDistanceValue(
        userInputs.actualDistance ??
        loggedSet?.distanceLogged ??
        plannedSet.targetDistance
      ),
      duration: this.workoutUtilsService.durationTargetAsString(
        userInputs.actualDuration ??
        loggedSet?.durationLogged ??
        plannedSet.targetDuration
      ),
      rest: this.workoutUtilsService.restTargetAsString(
        userInputs.actualRest ??
        loggedSet?.restLogged ??
        plannedSet.targetRest
      ),
      weightIcon: weightIcon
    };
  }

  /**
  * REFACTORED: Returns the rest duration for a set
  * Now uses the correct source (WorkoutGroup.config for supersets/circuits)
  */
  getSetRestDuration(exerciseId: string, setId: string): number {
    const routine = this.routine();
    if (!routine) return 0;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return 0;

    // Get the set index for block-aware lookups
    const setIndex = exercise.sets.findIndex(s => s.id === setId);
    if (setIndex === -1) return 0;

    // For supersets/circuits, check user input on the LAST exercise
    if (this.isExerciseInGroupBlock(exerciseId)) {
      const supersetExercises = this.getSupersetExercises(exerciseId);
      if (supersetExercises.length > 0) {
        const lastExercise = supersetExercises[supersetExercises.length - 1];
        const lastSetAtIndex = lastExercise.sets[setIndex];
        if (lastSetAtIndex) {
          // Check user input on the last exercise's set
          const key = this.getSetKey(lastExercise.id, lastSetAtIndex.id);
          const userInputs = this.performanceInputValues()[key] || {};
          if (userInputs.actualRest !== undefined && userInputs.actualRest !== null) {
            return getRestValue(userInputs.actualRest);
          }
        }
      }
    } else {
      // For standard exercises, check user input on the exercise itself
      const key = this.getSetKey(exerciseId, setId);
      const userInputs = this.performanceInputValues()[key] || {};
      if (userInputs.actualRest !== undefined && userInputs.actualRest !== null) {
        return getRestValue(userInputs.actualRest);
      }
    }

    // Use block-aware helper to get the planned rest value
    return this.getRestValueForBlock(exerciseId, setIndex);
  }

  /**
   * REFACTORED: Returns true if the rest timer should be visible
   * Now correctly checks WorkoutGroup.config.restBetweenRounds for supersets/circuits
   */
  isRestTimerVisibleForSet(exerciseId: string, setId: string): boolean {
    const routine = this.routine();
    if (!routine) return false;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise || !exercise.sets || exercise.sets.length === 0) return false;

    // Get the set index
    const setIndex = exercise.sets.findIndex(s => s.id === setId);
    if (setIndex === -1) return false;

    // Use block-aware helper to determine if there's rest for this set/round
    const restValue = this.getRestValueForBlock(exerciseId, setIndex);
    return restValue > 0;
  }

  restStartTimestamps: { [key: string]: number } = {};
  /**
  * UNCHANGED: Returns the remaining rest time for this set
  * Works correctly with the refactored duration methods
  */
  restTimerRemainingForSet(exerciseId: string, setId: string): number {
    if (!this.isRestTimerVisibleForSet(exerciseId, setId)) return 0;
    const restKey = this.getSetKey(exerciseId, setId);
    const startTimestamp = this.restStartTimestamps?.[restKey];
    const duration = this.getSetRestDuration(exerciseId, setId);
    if (!startTimestamp || !duration) return duration;
    const elapsed = Math.floor((Date.now() - startTimestamp) / 1000);
    const remaining = duration - elapsed;
    return Math.max(0, remaining);
  }

  // Returns how many seconds have elapsed since rest started for this set
  restTimerElapsedForSet(exerciseId: string, setId: string): number {
    const duration = this.getSetRestDuration(exerciseId, setId);
    const key = this.getSetKey(exerciseId, setId);
    const startTimestamp = this.restStartTimestamps?.[key];

    // If set is not completed, do not show progress
    if (!this.isSetCompleted(exerciseId, setId) || !startTimestamp) {
      return 0;
    }

    const elapsed = Math.floor((Date.now() - startTimestamp) / 1000);

    // If enough time has passed since completion, fill the bar
    if (elapsed >= duration) {
      return duration;
    } else {
      // Otherwise, show the actual elapsed time
      return Math.max(0, elapsed);
    }
  }


  // Returns progress (0-100) as the bar fills up
  restTimerProgressForSet(exerciseId: string, setId: string): number {
    const duration = this.getSetRestDuration(exerciseId, setId);
    const elapsed = this.restTimerElapsedForSet(exerciseId, setId);
    if (!duration || !this.isSetCompleted(exerciseId, setId)) return 0;
    return Math.max(0, Math.min(100, (elapsed / duration) * 100));
  }

  /**
   * Returns a unique key for a set, used for mapping inputs, timers, etc.
   * - For supersets: uses the supersetId and setId for uniqueness.
   * - For standard exercises: uses exerciseId and setId.
   */
  protected getSetKey(exerciseId: string, setId: string): string {
    const displayExercises = this.displayExercises();
    if (!displayExercises) return '';

    const exercise = displayExercises.find(ex => ex.id === exerciseId);
    if (!exercise) return '';

    // For supersets, use exerciseId and setId for uniqueness
    if (this.isExerciseInGroupBlock(exerciseId)) {
      return `${exerciseId}-round-${setId}`;
    }
    // For standard exercises
    return `${exerciseId}-${setId}`;
  }

  private compactRestInterval: any = null;
  private lastCompactRestBeepSecond: number | null = null;

  private alignRestStartTimestampsFromLog(): void {
    if (this.getRestTimerMode() !== this.restTimerModeEnum.Compact) return;
    const routine = this.routine();
    const log = this.currentWorkoutLog();
    if (!routine || !log.exercises) return;

    this.restStartTimestamps = {};

    routine.exercises.forEach((exercise, exIndex) => {
      exercise.sets.forEach((set, setIndex) => {
        const restValue = set.targetRest ? getRestValue(set.targetRest) : 0;
        if (restValue > 0) {
          // Find the matching logged exercise by id
          const logEx = log.exercises?.find(le => le.id === exercise.id);
          // Use plannedSetId logic for robust matching
          const plannedSetId = this.getPlannedSetId(exercise, set);
          const loggedSet = logEx?.sets.find(s => s.plannedSetId === plannedSetId);
          if (loggedSet?.timestamp) {
            const restKey = this.getSetKey(exercise.id, set.id);
            this.restStartTimestamps[restKey] = new Date(loggedSet.timestamp).getTime();
          }
        }
      });
    });
  }

  getPlannedSetId(exercise: WorkoutExercise, set: ExerciseTargetSetParams): string {
    return this.getSetKey(exercise.id, set.id);
  }

  getSetOrderIdByExercise(exercise: WorkoutExercise, setId: string): string {
    if (!exercise) return '';
    return this.getSetKey(exercise.id, setId);
  }

  addSectionExercise(exerciseId: string): void {
    const routine = this.routine();
    if (!routine) return;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise) return;
    this.workoutSectionService.addSectionToExerciseModal(exercise).then(updatedExercise => {
      if (!updatedExercise) return;

      this.routine.update(r => {
        if (!r) return r;
        let updatedSections = r.sections ? [...r.sections] : [];

        const sortedSections = updatedSections.slice().sort(
          (a, b) => WORKOUT_SECTION_TYPE_ORDER[a.type] - WORKOUT_SECTION_TYPE_ORDER[b.type]
        );

        // Remove the exercise from all sections
        updatedSections = updatedSections.map(section => ({
          ...section,
          exercises: section.exercises.filter(ex => ex.id !== updatedExercise.id)
        }));

        // Remove any section that is now empty
        updatedSections = updatedSections.filter(section => section.exercises.length > 0);

        // Add to the new section
        if (updatedExercise.section) {
          let sectionIndex = updatedSections.findIndex(sec => sec.type === updatedExercise.section);
          if (sectionIndex === -1) {
            // Create new section if it doesn't exist
            const newSection: WorkoutSection = {
              type: updatedExercise.section,
              id: uuidv4(),
              titleI18nKey: this.translate.instant(`workoutSections.${updatedExercise.section}`),
              exercises: [updatedExercise]
            };
            updatedSections.push(newSection);
          } else {
            // Add to existing section if not already present
            const section = updatedSections[sectionIndex];
            if (!section.exercises.some(ex => ex.id === updatedExercise.id)) {
              updatedSections[sectionIndex] = {
                ...section,
                exercises: [...section.exercises, updatedExercise]
              };
            }
          }
        }

        const newExercises = r.exercises.map((ex) =>
          ex.id === updatedExercise.id ? { ...ex, ...updatedExercise } : ex
        );
        return { ...r, exercises: newExercises, sections: updatedSections };
      });

      this.alignRestStartTimestampsFromLog();
    }).catch(error => {
      // handle any errors here
    });
  }


  addExerciseLog() {
    this.modalService.prompt({
      title: 'Log Set',
      confirmText: 'Save',
      fields: [
        // 1. Full Width (Default)
        {
          key: 'exerciseName',
          type: 'text',
          label: 'Exercise',
          value: 'Bench Press',
          cssClass: 'col-full' // Optional, as it's default
        },

        // 2. Left Column
        {
          key: 'weight',
          type: 'number',
          label: 'Weight (kg)',
          required: true,
          cssClass: 'col-half' // <--- MAGIC HERE
        },

        // 3. Right Column
        {
          key: 'reps',
          type: 'number',
          label: 'Reps',
          required: true,
          cssClass: 'col-half' // <--- MAGIC HERE
        },

        // 4. Full Width
        {
          key: 'notes',
          type: 'textarea',
          label: 'Notes',
          cssClass: 'col-full'
        }
      ]
    }).subscribe(res => console.log(res));
  }

  get orderedSections() {
    const routine = this.routine?.();
    if (!routine?.sections) return [];
    return [...routine.sections]
      .filter(section => section.type !== WorkoutSectionType.NONE)
      .sort(
        (a, b) =>
          (WORKOUT_SECTION_TYPE_ORDER[a.type] ?? 99) -
          (WORKOUT_SECTION_TYPE_ORDER[b.type] ?? 99)
      );
  }

  getIconPath(exerciseId: string): string {
    // Optimization: Use the already loaded availableExercises array to avoid async calls
    const routine = this.routine();
    let foundExerciseId = '';
    if (!routine || !routine.exercises || !routine.exercises.length || !routine.exercises.find((ex: WorkoutExercise) => ex.exerciseId === exerciseId)) {
      foundExerciseId = '';
    };
    const baseExercise = this.availableExercises.find(ex => ex.id === exerciseId);
    if (!baseExercise) {
      foundExerciseId = '';
    }
    return this.exerciseService.getIconPath(foundExerciseId);
  }

  isDarkTheme() {
    // Implement the logic to determine if the current theme is dark
    // This is a placeholder implementation
    return this.themeService.isDarkTheme();
  }


  /**
   * Shows a wizard to create a new routine from a template or blank.
   * Adapted for the current routine structure (signals, not forms).
   */
  async showCreationWizard(): Promise<void> {
    // Step 0: Template or Blank
    const templateResult = await this.alertService.showPromptDialog(
      this.translate.instant('workoutBuilder.wizard.templateOrBlankTitle'),
      this.translate.instant('workoutBuilder.wizard.templateOrBlankMsg'),
      [
        {
          name: 'routineTemplate',
          type: 'radio',
          label: this.translate.instant('workoutBuilder.wizard.templateOrBlankLabel'),
          value: 'blank',
          options: [
            { label: 'Blank (Custom)', value: 'blank' },
            { label: '3x3', value: '3x3' },
            { label: '5x5', value: '5x5' },
            { label: 'Push/Pull/Legs', value: 'ppl' },
            { label: '5/3/1', value: '531' }
          ],
          required: true
        }
      ],
      this.translate.instant('alertService.buttons.ok')
    );

    // IF NO WIZARD START COMPLETELY EMPTY WORKOUT
    if (!templateResult || !templateResult['routineTemplate']) {
      const emptyNewRoutine = {
        name: this.translate.instant('pausedWorkout.defaultRoutineName'),
        createdAt: new Date().toISOString(),
        goal: 'custom',
        exercises: [] as WorkoutExercise[],
      } as Routine;
      this.routine.set(emptyNewRoutine);
      this.startWorkout();
      return;
    };

    const routineTemplate = String(templateResult['routineTemplate']);
    if (routineTemplate !== 'blank') {
      await this.createRoutineFromTemplate(routineTemplate);
      return;
    }

    // Step 1: Routine Name
    const nameResult = await this.alertService.showPromptDialog(
      this.translate.instant('workoutBuilder.routineBuilder.nameLabel'),
      this.translate.instant('workoutBuilder.routineBuilder.nameWizardMsg'),
      [
        {
          name: 'routineName',
          type: 'text',
          label: this.translate.instant('workoutBuilder.routineBuilder.nameLabel'),
          placeholder: this.translate.instant('workoutBuilder.routineBuilder.namePlaceholder'),
          required: false,
          autofocus: true
        }
      ],
      this.translate.instant('alertService.buttons.ok')
    );
    if (!nameResult) return;
    if (!nameResult['routineName']) {
      nameResult['routineName'] = this.translate.instant('pausedWorkout.defaultRoutineName');
    }

    // Step 2: Routine Goal
    const routineGoals = [
      { value: 'hypertrophy', label: 'workoutBuilder.goals.hypertrophy' },
      { value: 'strength', label: 'workoutBuilder.goals.strength' },
      { value: 'endurance', label: 'workoutBuilder.goals.muscularEndurance' },
      { value: 'custom', label: 'workoutBuilder.goals.custom' }
    ];
    const goalResult = await this.alertService.showPromptDialog(
      this.translate.instant('workoutBuilder.routineBuilder.goalLabel'),
      this.translate.instant('workoutBuilder.routineBuilder.goalWizardMsg'),
      [
        {
          name: 'routineGoal',
          type: 'select',
          label: this.translate.instant('workoutBuilder.routineBuilder.goalLabel'),
          value: 'hypertrophy',
          options: routineGoals.map(g => ({
            label: this.translate.instant(g.label),
            value: g.value
          })),
          required: true
        }
      ],
      this.translate.instant('alertService.buttons.ok')
    );
    if (!goalResult || !goalResult['routineGoal']) return;

    // Set the routine signal with the new blank routine
    this.routine.set({
      name: nameResult['routineName'] as string,
      goal: goalResult['routineGoal'],
      exercises: [] as WorkoutExercise[],
      createdAt: new Date().toISOString()
    } as Routine);
    this._prefillPerformanceInputs();

    this.originalRoutineSnapshot.set(this.routine());
    this.cdr.detectChanges();
    this.startWorkout();
    this.toastService.success(this.translate.instant('workoutBuilder.wizard.templateCreated'), 3000);
  }

  /**
   * Creates a routine from a template and sets it as the current routine.
   * Adapted for the current routine structure (signals, not forms).
   */
  private async createRoutineFromTemplate(template: string) {
    // Use your WorkoutService's shared method
    const templateName = `${template} - ${this.translate.instant('workoutGenerator.routineName', { split: format(new Date(), 'yyyy-MM-dd') })}`;
    const routines = this.workoutService.generateRoutineFromTemplate(template, this.availableExercises, templateName);

    // For PPL/5/3/1, let user pick which routine to use, or just pick the first
    let routine: Routine;
    if (routines.length === 1) {
      routine = routines[0];
    } else {
      // Prompt user to pick which routine (e.g. Push, Pull, Legs)
      const pickResult = await this.alertService.showPromptDialog(
        this.translate.instant('workoutBuilder.wizard.pickRoutineTitle'),
        this.translate.instant('workoutBuilder.wizard.pickRoutineMsg'),
        [
          {
            name: 'routinePick',
            type: 'select',
            label: this.translate.instant('workoutBuilder.wizard.pickRoutineLabel'),
            value: routines[0].id,
            options: routines.map(r => ({ label: r.name, value: r.id })),
            required: true
          }
        ],
        this.translate.instant('alertService.buttons.ok')
      );
      if (!pickResult || !pickResult['routinePick']) return;
      routine = routines.find(r => r.id === pickResult['routinePick']) || routines[0];
    }

    // Set the routine signal with the template routine
    this.routine.set({ ...routine, createdAt: new Date().toISOString() });
    this.originalRoutineSnapshot.set({ ...routine, createdAt: new Date().toISOString() });
    this._prefillPerformanceInputs();
    this.cdr.detectChanges();
    this.toastService.success(this.translate.instant('workoutBuilder.wizard.templateCreated'), 3000);
  }

  isExerciseDetailModalOpen = signal(false);
  isSimpleModalOpen = signal(false);
  exerciseDetailsId: string = '';
  exerciseDetailsName: string = '';
  openModal(exerciseId: string, event?: Event) {
    event?.stopPropagation();
    this.exerciseDetailsId = exerciseId;
    this.exerciseDetailsName = 'Exercise details';
    this.isSimpleModalOpen.set(true);
  }

  private supersetSummaryCache = new Map<string, SetInfo[]>();
  /**
   * Returns an array of objects for each exercise in a superset round,
   * containing all info needed for metricInputSpan.
   * Each entry is for the set at roundIndex for each exercise in the superset group.
   * @param exIndex The index of any exercise in the superset group
   * @param roundIndex The round (set) index within the superset
   */
  getSupersetSummaryMetricsDetailed(
    exerciseId: string, setId: string
  ): SetInfo[] {
    // const cacheKey = `${exIndex}-${roundIndex}-${this.routine()?.exercises?.length ?? 0}`;
    // if (this.supersetSummaryCache.has(cacheKey)) {
    //   return this.supersetSummaryCache.get(cacheKey)!;
    // }

    const routine = this.routine();
    if (!routine) return [];
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise || !this.isExerciseInGroupBlock(exerciseId)) return [];

    const exercisesInGroup = this.getSupersetExercises(exerciseId);

    // const result = exercisesInGroup
    return exercisesInGroup
      .map((ex): SetInfo[] => {
        const exIdx = this.getOriginalExId(ex.id);
        if (exIdx === '') return [];
        const plannedSet = ex.sets.find(s => s.id === setId);
        if (!plannedSet) return [];
        const loggedSet = this.getLoggedSet(exIdx, setId);
        const key = this.getSetKey(exIdx, setId);
        const userInputs = this.performanceInputValues()[key] || {};

        let weightIcon = 'body';
        let weightValue: any = this.workoutUtilsService.weightTargetAsString(
          userInputs.actualWeight ?? loggedSet?.weightLogged ?? plannedSet.targetWeight
        );
        const weightTargetType = this.getWeightTargetType(
          userInputs.actualWeight ?? loggedSet?.weightLogged ?? plannedSet.targetWeight
        );
        switch (weightTargetType) {
          case WeightTargetType.exact:
          case WeightTargetType.range:
          case WeightTargetType.percentage_1rm:
            weightIcon = 'weight';
            break;
          case WeightTargetType.bodyweight:
            break;
        }
        if (!isNaN(Number(weightValue)) && weightValue !== '') {
          weightValue = `${weightValue} ${this.unitsService.getWeightUnitSuffix()}`;
          weightIcon = 'weight';
        }

        const repsValue = this.workoutUtilsService.repsTargetAsString(
          userInputs.actualReps ?? loggedSet?.repsLogged ?? plannedSet.targetReps
        );
        const distanceValue = this.getDistanceValue(
          userInputs.actualDistance ?? loggedSet?.distanceLogged ?? plannedSet.targetDistance
        );
        const durationValue = this.workoutUtilsService.durationTargetAsString(
          userInputs.actualDuration ?? loggedSet?.durationLogged ?? plannedSet.targetDuration
        );

        return [
          {
            icon: 'repeat',
            iconClass: 'h-4 w-4 mr-0.5 inline-block',
            metric: METRIC.reps,
            value: repsValue,
            exerciseId: exercise.id,
            setId: plannedSet.id,
            suffix: this.translate.instant('compactPlayer.repsLabel'),
          },
          {
            icon: weightIcon,
            iconClass: 'h-5 w-5 mr-0.5 inline-block',
            metric: METRIC.weight,
            value: weightValue,
            exerciseId: exercise.id,
            setId: plannedSet.id,
            suffix: this.unitsService.getWeightUnitSuffix(),
          },
          {
            icon: 'distance',
            iconClass: 'h-4 w-4 mr-0.5 inline-block',
            metric: METRIC.distance,
            value: distanceValue,
            exerciseId: exercise.id,
            setId: plannedSet.id,
            suffix: this.unitsService.getDistanceUnitSuffix(),
          },
          {
            icon: 'duration',
            iconClass: 'h-4 w-4 mr-0.5 inline-block',
            metric: METRIC.duration,
            value: durationValue,
            exerciseId: exercise.id,
            setId: plannedSet.id,
            suffix: 's',
          },
        ];
      })
      .flat()
      .filter(
        (entry): entry is SetInfo =>
          !!entry &&
          entry.value !== undefined &&
          entry.value !== null &&
          entry.value !== '' &&
          entry.value !== 0
      );

    // this.supersetSummaryCache.set(cacheKey, result);
    // return result;
  }

  trackByMetric(index: number, metric: SetInfo) {
    // Use a unique combination of exerciseId, setId, and metric type
    return `${metric.exerciseId}-${metric.setId}-${metric.metric}`;
  }
  supersetSummaryMetrics = computed(() => {
    const routine = this.routine();
    const perfInputs = this.performanceInputValues();
    if (!routine) return {};

    const result: { [key: string]: SetInfo[] } = {};

    // Get all exercises as flat array (block-aware)
    const allExercises = this.workoutService.getExercisesFlat(routine);

    // Identify all group blocks
    if (routine.blocks && Array.isArray(routine.blocks)) {
      routine.blocks.forEach(block => {
        if (block.type === 'group') {
          const exercisesInGroup = block.data.exercises;
          const firstExercise = exercisesInGroup[0];

          if (!firstExercise) return;

          // Use the first exercise's sets as the "rounds"
          firstExercise.sets.forEach((round, roundIndex) => {
            // For EACH exercise in the superset group, create a key and compute metrics
            exercisesInGroup.forEach(exercise => {
              //  KEY FIX: Use roundIndex to get the set at the same position in THIS exercise
              const actualSet = exercise.sets[roundIndex];
              if (!actualSet) return;

              //  Create key using the actual set ID of THIS exercise
              const key = this.getSetKey(exercise.id, actualSet.id);
              result[key] = this._computeSupersetSummaryMetrics(exercise.id, actualSet.id, routine, perfInputs);
            });
          });
        }
      });
    }

    return result;
  });

  private _computeSupersetSummaryMetrics(
    exerciseId: string, setId: string,
    routine: Routine,
    perfInputs: { [key: string]: Partial<ExerciseCurrentExecutionSetParams> }
  ): SetInfo[] {
    // Use block-aware method to get all exercises
    const allExercises = this.workoutService.getExercisesFlat(routine);
    const exercise = allExercises.find(ex => ex.id === exerciseId);

    if (!this.isExerciseInGroupBlock(exerciseId) || !exercise) return [];

    // Get the planned set directly - it's passed by setId
    const plannedSet = exercise.sets.find(set => set.id === setId);
    if (!plannedSet) return [];

    // Rest of the method remains the same (compute metrics from plannedSet)
    const metrics: SetInfo[] = [];

    const setKey = this.getSetKey(exercise.id, plannedSet.id);
    const userInputs = perfInputs[setKey] || {};

    // Collect visible metrics in order
    const fieldOrder = this.workoutUtilsService.getSetFieldOrderByStrings(routine, exercise.id, plannedSet.id);
    const fieldsToDisplay = fieldOrder?.filter(f => f !== METRIC.rest) || [];

    fieldsToDisplay.forEach(metric => {
      let value: any;
      let suffix = '';

      switch (metric) {
        case METRIC.reps:
          value = userInputs.actualReps ?? plannedSet?.targetReps;
          suffix = 'x';
          break;
        case METRIC.weight:
          value = userInputs.actualWeight ?? plannedSet?.targetWeight;
          suffix = this.unitsService.getWeightUnitSuffix();
          break;
        case METRIC.duration:
          value = userInputs.actualDuration ?? plannedSet?.targetDuration;
          suffix = 's';
          break;
        case METRIC.distance:
          value = userInputs.actualDistance ?? plannedSet?.targetDistance;
          suffix = this.unitsService.getDistanceUnitSuffix();
          break;
      }

      if (value !== undefined && value !== null) {
        metrics.push({
          icon: metric,
          iconClass: `text-gray-700 dark:text-gray-300`,
          metric: metric as METRIC,
          value: value,
          exerciseId: exercise.id,
          setId: plannedSet!.id,
          suffix: suffix
        });
      }
    });

    return metrics;
  }

  /**
 * Checks if a set (standard) or round (superset) is completed.
 * For standard exercises, checks the set at setOrRoundIndex.
 * For supersets, checks all exercises in the group at setOrRoundIndex.
 * @param exIndex Index of the exercise in the routine
 * @param setOrRoundIndex Index of the set (for standard) or round (for superset)
 */
  isSetOrRoundCompleted(exerciseId: string, setId: string): boolean {
    const routine = this.routine();
    if (!routine) return false;
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!exercise) return false;

    if (this.isExerciseInGroupBlock(exerciseId)) {
      // Superset: check all exercises in the group for this round
      const exercisesInGroup = this.getSupersetExercises(exerciseId);
      return exercisesInGroup.every(ex => {
        const originalExIndex = this.getOriginalExId(ex.id);
        return this.getLoggedSet(originalExIndex, setId) !== undefined;
      });
    } else {
      // Standard: check just this set
      return this.getLoggedSet(exerciseId, setId) !== undefined;
    }
  }




  /**
  * Validates that all exercises in the routine exist in the available exercises list.
  * If non-existing exercises are found, prompts the user to either remove or replace them.
  * Returns the cleaned routine.
  */
  private async validateAndFixMissingExercises(routine: Routine): Promise<Routine> {
    const exercisesMap = new Map(this.availableExercises.map(ex => [ex.id, ex]));
    const nonExistingExercises = routine.exercises.filter(ex => !exercisesMap.has(ex.exerciseId));

    if (nonExistingExercises.length === 0) {
      return routine; // All exercises exist
    }

    // Build a message showing the non-existing exercises
    const exerciseNames = nonExistingExercises.map((ex, idx) => `${idx + 1}. ${ex.exerciseName || ex.exerciseId}`).join('\n');
    const title = this.translate.instant('compactPlayer.alerts.missingExercisesTitle');
    const message = this.translate.instant('compactPlayer.alerts.missingExercisesMessage', { exercises: exerciseNames });

    // Show options to the user
    const result = await this.alertService.showConfirm(
      title,
      message,
      this.translate.instant('compactPlayer.alerts.replaceExercises'),
      this.translate.instant('compactPlayer.alerts.removeExercises')
    );

    if (!result?.data) {
      // User chose to remove exercises
      return this.removeMissingExercises(routine, nonExistingExercises);
    } else {
      // User chose to replace exercises - open modal for each missing exercise
      return await this.replaceMissingExercises(routine, nonExistingExercises);
    }
  }

  /**
   * Removes all missing exercises from the routine.
   */
  private removeMissingExercises(routine: Routine, missingExercises: WorkoutExercise[]): Routine {
    const missingIds = new Set(missingExercises.map(ex => ex.id));
    const updatedRoutine = JSON.parse(JSON.stringify(routine)) as Routine;

    updatedRoutine.exercises = updatedRoutine.exercises.filter(ex => !missingIds.has(ex.id));

    const removedCount = missingExercises.length;
    this.toastService.warning(
      this.translate.instant('compactPlayer.alerts.exercisesRemoved', { count: removedCount }),
      5000
    );

    return updatedRoutine;
  }

  /**
 * Prompts the user to select a replacement exercise for a missing one.
 * Opens a modal and waits for selection.
 */
  private promptUserForExerciseReplacement(missingExercise: WorkoutExercise): Promise<Exercise | null> {
    return new Promise((resolve) => {
      // Set up the modal with the replacement callback
      this.missingExerciseToReplace.set(missingExercise);
      this.missingExerciseReplacementCallback.set((selectedExercise: Exercise | null) => {
        this.missingExerciseReplacementModal.set(false);
        this.missingExerciseToReplace.set(null);
        this.missingExerciseReplacementCallback.set(null);
        resolve(selectedExercise);
      });

      // Show the modal
      this.exercisesForSwitchModal.set(this.availableExercises);
      this.modalSearchTerm.set('');
      this.missingExerciseReplacementModal.set(true);
    });
  }

  /**
    * Opens a modal for each missing exercise to let the user select a replacement.
    */
  private async replaceMissingExercises(routine: Routine, missingExercises: WorkoutExercise[]): Promise<Routine> {
    const updatedRoutine = JSON.parse(JSON.stringify(routine)) as Routine;

    for (const missingExercise of missingExercises) {
      const replacement = await this.promptUserForExerciseReplacement(missingExercise);

      if (replacement) {
        // Find and update the exercise in the routine
        const exerciseToUpdate = updatedRoutine.exercises.find(ex => ex.id === missingExercise.id);
        if (exerciseToUpdate) {
          const newBaseExercise = replacement;
          const isNewCardio = newBaseExercise.categories.find(cat => cat === EXERCISE_CATEGORY_TYPES.cardio) !== undefined;

          // Reset set targets for the new exercise type
          exerciseToUpdate.sets.forEach(set => {
            if (isNewCardio) {
              set.targetWeight = undefined;
              set.targetReps = undefined;
              set.targetDistance = distanceToExact(1);
              set.targetDuration = durationToExact(300);
            } else {
              set.targetDistance = undefined;
              set.targetDuration = undefined;
              set.targetWeight = weightToExact(10);
              set.targetReps = genRepsTypeFromRepsNumber(8);
            }
            set.targetRest = restToExact(60);
          });

          exerciseToUpdate.exerciseId = newBaseExercise.id;
          exerciseToUpdate.exerciseName = newBaseExercise.name;

          this.toastService.success(
            this.translate.instant('compactPlayer.alerts.exerciseReplaced', {
              old: missingExercise.exerciseName || missingExercise.exerciseId,
              new: newBaseExercise.name
            }),
            3000
          );
        }
      } else {
        // User cancelled for this exercise, remove it
        const indexToRemove = this.getExerciseIndexById(updatedRoutine, missingExercise.id);
        if (indexToRemove > -1) {
          updatedRoutine.exercises.splice(indexToRemove, 1);
          this.toastService.info(
            this.translate.instant('compactPlayer.alerts.exerciseRemovedCancelled', {
              name: missingExercise.exerciseName
            }),
            3000
          );
        }
      }
    }

    return updatedRoutine;
  }

  /**
   * Handles exercise selection from the missing exercise replacement modal.
   */
  onMissingExerciseSelected(exercise: Exercise): void {
    const callback = this.missingExerciseReplacementCallback();
    if (callback) {
      callback(exercise);
    }
  }

  /**
   * Cancels the missing exercise replacement modal.
   */
  closeMissingExerciseReplacementModal(): void {
    const callback = this.missingExerciseReplacementCallback();
    if (callback) {
      callback(null); // null signals cancellation
    }
    this.missingExerciseReplacementModal.set(false);
    this.missingExerciseToReplace.set(null);
    this.missingExerciseReplacementCallback.set(null);
  }


  /**
   * For a non-first exercise in a superset, finds its set at the same index as the first exercise's roundSetId.
   * Returns the actual setId for that exercise, or the original roundSetId if not found.
   */
  /**
   * For a superset exercise, gets its actual set at a given index in the first exercise's sets.
   * Since each exercise in a superset has its own sets array with different IDs,
   * we need to match by INDEX, not by ID.
   */
  getSupersetExerciseSetAtRoundIndex(exerciseId: string, roundIndexFromFirstExercise: number): ExerciseTargetSetParams | null {
    const routine = this.routine();
    if (!routine) return null;

    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise || !this.isExerciseInGroupBlock(exerciseId)) return null;

    // Get the actual set at this index from the exercise
    const actualSet = exercise.sets[roundIndexFromFirstExercise];
    return actualSet || null;
  }

  

  /**
  * Gets exercises as a flat array, with block awareness
  * Ensures we're working with the latest structure
  */
  private getDisplayExercises(routine: Routine | null | undefined): WorkoutExercise[] {
    if (!routine || !routine.exercises) return [];
    return routine.exercises;
  }

  /**
 * Retrieves an exercise from routine using block-aware logic.
 * Works with both block-based and legacy flat array structures.
 * @param routine The routine to search in
 * @param exerciseId The exercise ID to find
 * @returns The exercise if found, undefined otherwise
 */
  private getWorkoutExerciseById(routine: Routine | null | undefined, exerciseId: string): WorkoutExercise | undefined {
    const exerciseIndex = this.getExerciseIndexById(routine, exerciseId);
    if (exerciseIndex !== -1 && routine) {
      return routine.exercises[exerciseIndex];
    }
    return undefined;
  }

  /**
   * Finds the index of an exercise in the routine using block-aware logic.
   * @param routine The routine to search in
   * @param exerciseId The exercise ID to find
   * @returns The index of the exercise, or -1 if not found
   */
  private getExerciseIndexById(routine: Routine | null | undefined, exerciseId: string): number {
    if (!routine || !exerciseId || !routine.exercises) return -1;
    return routine.exercises.findIndex(ex => ex.id === exerciseId);
  }

  /**
   * Gets a specific set from an exercise using block-aware logic.
   * @param routine The routine containing the exercise
   * @param exerciseId The exercise ID
   * @param setId The set ID to find
   * @returns The set if found, undefined otherwise
   */
  private getSetById(routine: Routine | null | undefined, exerciseId: string, setId: string): ExerciseTargetSetParams | undefined {
    if (!routine) return undefined;
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    return exercise?.sets.find(s => s.id === setId);
  }


  /**
  * REFACTORED MAIN REST HELPER
  * 
  * Now correctly uses WorkoutGroup.config.restBetweenRounds as the authoritative source
  * for supersets/circuits instead of checking individual exercise rest values.
  * 
  * LOGIC:
  * - For STANDARD EXERCISES: Uses the exercise's own targetRest
  * - For EMOM: Uses exercise's own rest (EMOM timing is managed separately)
  * 
  * @param exerciseId The ID of the current exercise (any exercise in the group)
  * @param setOrRoundIndex The index of the set (for standard) or round (for EMOM/superset)
  * @returns The rest target object, or undefined if not applicable
  */
  private getRestForSuperset(exerciseId: string, setOrRoundIndex: number): any {
    const routine = this.routine();
    const exercise = this.getWorkoutExerciseById(routine, exerciseId);
    if (!exercise || setOrRoundIndex < 0 || setOrRoundIndex >= exercise.sets.length) {
      return undefined;
    }
    // get first superset exercise
    const block = this.getBlockForExercise(exerciseId);

    
  }

    public getSupersetGroupExercises(exerciseId: string): WorkoutExercise[] {
        const routine = this.routine();
        if (!routine) return [];
        const exercise = this.getWorkoutExerciseById(routine, exerciseId);
        const supersetId = exercise?.supersetId;
        if (!supersetId) {
            return []; // Return empty if it's not in a superset
        }

        // Filter all exercises to find those with the same superset ID
        return routine.exercises
            .filter(ex => ex.supersetId === supersetId)
            .sort((a, b) => ((a as WorkoutExercise).supersetOrder ?? 0) - ((b as WorkoutExercise).supersetOrder ?? 0));
    }
  

  /**
   * REFACTORED: Get rest value considering user input override
   * Now properly prioritizes user input and uses the new rest source
   * @param exerciseId The ID of the current exercise
   * @param setOrRoundId The ID of the set (for user input lookup)
   * @param setOrRoundIndex The index of the set/round
   * @returns The effective rest duration in seconds
   */
  private getEffectiveRestForBlock(exerciseId: string, setOrRoundId: string, setOrRoundIndex: number): number {
    const exercise = this.getWorkoutExerciseById(this.routine(), exerciseId);
    if (!this.isExerciseInGroupBlock(exerciseId)) {
      // For standard exercises, use the exercise's own input
      const key = this.getSetKey(exerciseId, setOrRoundId);
      const userInputs = this.performanceInputValues()[key] || {};
      if (userInputs.actualRest !== undefined && userInputs.actualRest !== null) {
        return getRestValue(userInputs.actualRest);
      }
    } else {
      // For supersets/circuits, check the LAST exercise for user input override
      const supersetExercises = this.getSupersetExercises(exerciseId);
      if (supersetExercises.length > 0) {
        const lastExercise = supersetExercises[supersetExercises.length - 1];
        const lastSet = lastExercise.sets[setOrRoundIndex];
        if (lastSet) {
          const key = this.getSetKey(lastExercise.id, lastSet.id);
          const userInputs = this.performanceInputValues()[key] || {};
          if (userInputs.actualRest !== undefined && userInputs.actualRest !== null) {
            return getRestValue(userInputs.actualRest);
          }
        }
      }
    }

    // PRIORITY 2: Block-aware rest retrieval (now uses WorkoutGroup.config)
    return this.getRestValueForBlock(exerciseId, setOrRoundIndex);
  }

  /**
 * ========== BLOCK-AWARE HELPER METHODS FOR PLAYER ==========
 * These methods abstract block operations for clean playback logic
 */

  /**
   * Finds the block containing a given exercise by its ID
   * @param exerciseId The ID of the exercise
   * @returns The block containing the exercise, or null if not found
   */
  private getBlockForExercise(exerciseId: string): WorkoutBlock | null {
    const routine = this.routine();
    if (!routine?.blocks) return null;

    return routine.blocks.find(block => {
      if (block.type === 'single') {
        return block.data.id === exerciseId;
      } else {
        return block.data.exercises.some(ex => ex.id === exerciseId);
      }
    }) || null;
  }

  /**
   * Checks if an exercise is part of a group block
   * @param exerciseId The ID of the exercise
   * @returns True if in a group block, false if standalone or not found
   */
  private isExerciseInGroupBlock(exerciseId: string): boolean {
    const block = this.getBlockForExercise(exerciseId);
    return block?.type === 'group' || false;
  }

  /**
   * Gets the group type (superset, circuit, emom) for an exercise
   * @param exerciseId The ID of the exercise
   * @returns The group type, or null if standalone
   */
  private getBlockType(exerciseId: string): 'superset' | 'circuit' | 'emom' | 'amrap_round' | null {
    const block = this.getBlockForExercise(exerciseId);
    if (!block || block.type === 'single') return null;
    return block.data.type;
  }

  /**
   * Gets all exercises in the same block group
   * @param exerciseId The ID of any exercise in the group
   * @returns Array of exercises in the group, or single-item array if standalone
   */
  private getExercisesInSameBlock(exerciseId: string): WorkoutExercise[] {
    const block = this.getBlockForExercise(exerciseId);
    if (!block) return [];
    return block.type === 'group' ? block.data.exercises : [this.getWorkoutExerciseById(this.routine(), exerciseId)!].filter(Boolean);
  }

  /**
   * Gets all exercise IDs in the same block
   * @param exerciseId The ID of any exercise in the group
   * @returns Array of exercise IDs in the group
   */
  private getExerciseIdsInSameBlock(exerciseId: string): string[] {
    return this.getExercisesInSameBlock(exerciseId).map(ex => ex.id);
  }

  /**
   * Gets the position of an exercise within its block
   * @param exerciseId The ID of the exercise
   * @returns 0-based position, or 0 if standalone
   */
  private getPositionInBlock(exerciseId: string): number {
    const block = this.getBlockForExercise(exerciseId);
    if (!block || block.type === 'single') return 0;
    return block.data.exercises.findIndex(ex => ex.id === exerciseId);
  }

  /**
   * Gets the total size of the block
   * @param exerciseId The ID of any exercise in the block
   * @returns Number of exercises in the block
   */
  private getBlockSize(exerciseId: string): number {
    const block = this.getBlockForExercise(exerciseId);
    if (!block) return 1;
    return block.type === 'group' ? block.data.exercises.length : 1;
  }

  /**
   * Gets the rest configuration for a block (for supersets/circuits)
   * @param exerciseId The ID of any exercise in the block
   * @returns The restBetweenRounds value, or undefined
   */
  private getBlockRestConfig(exerciseId: string): any {
    const block = this.getBlockForExercise(exerciseId);
    if (!block || block.type === 'single') return undefined;
    return block.data.config?.restBetweenRounds;
  }

  /**
   * Gets the EMOM interval for a block (for EMOM exercises)
   * @param exerciseId The ID of any exercise in the block
   * @returns The emomInterval value in seconds, or 60 if not found
   */
  private getBlockEmomInterval(exerciseId: string): number {
    const block = this.getBlockForExercise(exerciseId);
    if (!block || block.type === 'single') return 60;
    return block.data.config?.emomInterval || 60;
  }

  /**
   * ========== END BLOCK-AWARE HELPERS ==========
   */


}

export interface SetInfo {
  icon: string;
  iconClass: string;
  metric: METRIC;
  value: any;
  exerciseId: string;
  setId: string;
  suffix: string;
}

// this.isSetCompleted(exIndex, setIndex)